Index: libotr-3.2.0/src/context.h
===================================================================
--- libotr-3.2.0/src/context.h	(revision 4)
+++ libotr-3.2.0/src/context.h	(working copy)
@@ -128,6 +128,8 @@
 
     OtrlSMState *smstate;              /* The state of the current
                                           socialist millionaires exchange */
+
+	int datalen; // holds the length of the decrypted buffer
 } ConnContext;
 
 #include "userstate.h"
Index: libotr-3.2.0/src/message.c
===================================================================
--- libotr-3.2.0/src/message.c	(revision 4)
+++ libotr-3.2.0/src/message.c	(working copy)
@@ -74,7 +74,7 @@
 	const char *recipient, const char *message, OtrlTLV *tlvs,
 	char **messagep,
 	void (*add_appdata)(void *data, ConnContext *context),
-	void *data)
+	void *data, size_t msglen)
 {
     struct context * context;
     char * msgtosend;
@@ -193,7 +193,7 @@
 	case OTRL_MSGSTATE_ENCRYPTED:
 	    /* Create the new, encrypted message */
 	    err = otrl_proto_create_data(&msgtosend, context, message, tlvs,
-		    0);
+		    0, msglen);
 	    if (!err) {
 		context->lastsent = time(NULL);
 		*messagep = msgtosend;
@@ -454,7 +454,7 @@
 
 	/* Re-encrypt the message with the new keys */
 	err = otrl_proto_create_data(&resendmsg,
-		edata->context, edata->context->lastmessage, NULL, 0);
+		edata->context, edata->context->lastmessage, NULL, 0, strlen(edata->context->lastmessage));
 	if (!err) {
 	    const char *format = "<b>The last message "
 		"to %s was resent.</b>";
@@ -581,7 +581,7 @@
 	    : OTRL_TLV_SMP2,
 	    smpmsglen, smpmsg);
     err = otrl_proto_create_data(&sendsmp, context, "", sendtlv,
-            OTRL_MSGFLAGS_IGNORE_UNREADABLE);
+            OTRL_MSGFLAGS_IGNORE_UNREADABLE, 0);
     if (!err) {
         /*  Send it, and set the next expected message to the
 	 *  logical response */
@@ -634,7 +634,7 @@
 
     err = otrl_proto_create_data(&sendsmp,
 	    context, "", sendtlv,
-	    OTRL_MSGFLAGS_IGNORE_UNREADABLE);
+	    OTRL_MSGFLAGS_IGNORE_UNREADABLE, 0);
     if (!err) {
 	/* Send the abort signal so our buddy knows we've stopped */
 	err = otrl_message_fragment_and_send(ops, opdata, context,
@@ -1067,7 +1067,7 @@
 				    nextmsg);
 			    err = otrl_proto_create_data(&sendsmp,
 				    context, "", sendtlv,
-				    OTRL_MSGFLAGS_IGNORE_UNREADABLE);
+				    OTRL_MSGFLAGS_IGNORE_UNREADABLE, 0);
 			    if (!err) {
 				err = otrl_message_fragment_and_send(ops,
 					opdata, context, sendsmp,
@@ -1099,7 +1099,7 @@
 				    nextmsg);
 			    err = otrl_proto_create_data(&sendsmp,
 				    context, "", sendtlv,
-				    OTRL_MSGFLAGS_IGNORE_UNREADABLE);
+				    OTRL_MSGFLAGS_IGNORE_UNREADABLE, 0);
 			    if (!err) {
 				err = otrl_message_fragment_and_send(ops,
 					opdata, context, sendsmp,
@@ -1147,7 +1147,7 @@
 			    /* Create the heartbeat message */
 			    err = otrl_proto_create_data(&heartbeat,
 				    context, "", NULL,
-				    OTRL_MSGFLAGS_IGNORE_UNREADABLE);
+				    OTRL_MSGFLAGS_IGNORE_UNREADABLE, 0);
 			    if (!err) {
 				/* Send it, and log a debug message */
 				if (ops->inject_message) {
@@ -1430,7 +1430,7 @@
 	    OtrlTLV *tlv = otrl_tlv_new(OTRL_TLV_DISCONNECTED, 0, NULL);
 
 	    err = otrl_proto_create_data(&encmsg, context, "", tlv,
-		    OTRL_MSGFLAGS_IGNORE_UNREADABLE);
+		    OTRL_MSGFLAGS_IGNORE_UNREADABLE, 0);
 	    if (!err) {
 		ops->inject_message(opdata, accountname, protocol,
 			username, encmsg);
Index: libotr-3.2.0/src/message.h
===================================================================
--- libotr-3.2.0/src/message.h	(revision 4)
+++ libotr-3.2.0/src/message.h	(working copy)
@@ -139,7 +139,7 @@
 	const char *recipient, const char *message, OtrlTLV *tlvs,
 	char **messagep,
 	void (*add_appdata)(void *data, ConnContext *context),
-	void *data);
+	void *data, size_t msglen);
 
 /* Handle a message just received from the network.  It is safe to pass
  * all received messages to this routine.  add_appdata is a function
Index: libotr-3.2.0/src/proto.c
===================================================================
--- libotr-3.2.0/src/proto.c	(revision 4)
+++ libotr-3.2.0/src/proto.c	(working copy)
@@ -362,9 +362,8 @@
  * optional chain of TLVs.  A newly-allocated string will be returned in
  * *encmessagep. */
 gcry_error_t otrl_proto_create_data(char **encmessagep, ConnContext *context,
-	const char *msg, const OtrlTLV *tlvs, unsigned char flags)
+	const char *msg, const OtrlTLV *tlvs, unsigned char flags, size_t justmsglen)
 {
-    size_t justmsglen = strlen(msg);
     size_t msglen = justmsglen + 1 + otrl_tlv_seriallen(tlvs);
     size_t buflen;
     size_t pubkeylen;
@@ -393,7 +392,7 @@
     if (msgdup == NULL) {
 	return gcry_error(GPG_ERR_ENOMEM);
     }
-    strcpy(msgdup, msg);
+	memcpy(msgdup, msg, justmsglen + 1);
 
     *encmessagep = NULL;
 
@@ -641,6 +640,7 @@
     read_int(datalen);
     require_len(datalen);
     data = malloc(datalen+1);
+	context->datalen = datalen;
     if (!data) {
 	err = gcry_error(GPG_ERR_ENOMEM);
 	goto err;
Index: libotr-3.2.0/src/proto.h
===================================================================
--- libotr-3.2.0/src/proto.h	(revision 4)
+++ libotr-3.2.0/src/proto.h	(working copy)
@@ -127,7 +127,7 @@
  * optional chain of TLVs.  A newly-allocated string will be returned in
  * *encmessagep. */
 gcry_error_t otrl_proto_create_data(char **encmessagep, ConnContext *context,
-	const char *msg, const OtrlTLV *tlvs, unsigned char flags);
+	const char *msg, const OtrlTLV *tlvs, unsigned char flags, size_t justmsglen);
 
 /* Extract the flags from an otherwise unreadable Data Message. */
 gcry_error_t otrl_proto_data_read_flags(const char *datamsg,
Index: MirOTR/DLG_smp.cpp
===================================================================
--- MirOTR/DLG_smp.cpp	(revision 4)
+++ MirOTR/DLG_smp.cpp	(working copy)
@@ -10,87 +10,87 @@
 	return iter->second;
 }
 
-/* Create the SMP dialog.  responder is true if this is called in
- * response to someone else's run of SMP. */
-static void dialog_socialist_millionaires(ConnContext *context,
-	TCHAR *question, bool responder)
-{
-    if (context == NULL) return;
-	TCHAR primary[1024];
-
-    if (responder && question) {
-		(HANDLE)context->app_data
-        mir_sntprintf(primary, 1024, TranslateT(LANG_SMP_AUTH_FROM),
-            contact_get_nameT((HANDLE)context->app_data));
-    } else {
-        mir_sntprintf(primary, 1024, TranslateT(LANG_SMP_AUTH),
-            contact_get_nameT((HANDLE)context->app_data));
-    }
-    
-    /* fprintf(stderr, "Question = ``%s''\n", question); */
-	//TCHAR* proto_name = mir_a2t(context->protocol);
-	//if (!proto_name) proto_name = mir_tstrdup(TranslateT(LANG_UNKNOWN));
-    
-
-    dialog = create_smp_dialog(_("Authenticate Buddy"),
-	    primary, context, responder, question);
-
-    //mir_free(proto_name);
-}
-
-/* Call this to update the status of an ongoing socialist millionaires
- * protocol.  Progress_level is a percentage, from 0.0 (aborted) to
- * 1.0 (complete).  Any other value represents an intermediate state. */
-static void otrg_gtk_dialog_update_smp(ConnContext *context,
-	double progress_level)
-{
-    PurpleConversation *conv = otrg_plugin_context_to_conv(context, 0);
-    GtkProgressBar *bar;
-    SMPData *smp_data = purple_conversation_get_data(conv, "otr-smpdata");
-
-    if (!smp_data) return;
-
-    bar = GTK_PROGRESS_BAR(smp_data->smp_progress_bar);
-    gtk_progress_bar_set_fraction(bar, progress_level);
-
-    /* If the counter is reset to absolute zero, the protocol has aborted */
-    if (progress_level == 0.0) {
-        GtkDialog *dialog = GTK_DIALOG(smp_data->smp_progress_dialog);
-
-	gtk_dialog_set_response_sensitive(dialog, GTK_RESPONSE_ACCEPT, 1);
-	gtk_dialog_set_response_sensitive(dialog, GTK_RESPONSE_REJECT, 0);
-	gtk_dialog_set_default_response(GTK_DIALOG(dialog),
-		GTK_RESPONSE_ACCEPT);
-
-	gtk_label_set_text(GTK_LABEL(smp_data->smp_progress_label),
-		_("An error occurred during authentication."));
-	return;
-    } else if (progress_level == 1.0) {
-	/* If the counter reaches 1.0, the protocol is complete */
-        GtkDialog *dialog = GTK_DIALOG(smp_data->smp_progress_dialog);
-
-	gtk_dialog_set_response_sensitive(dialog, GTK_RESPONSE_ACCEPT, 1);
-	gtk_dialog_set_response_sensitive(dialog, GTK_RESPONSE_REJECT, 0);
-	gtk_dialog_set_default_response(GTK_DIALOG(dialog),
-		GTK_RESPONSE_ACCEPT);
-
-        if (context->smstate->sm_prog_state == OTRL_SMP_PROG_SUCCEEDED) {
-	    if (context->active_fingerprint->trust &&
-		    context->active_fingerprint->trust[0]) {
-		gtk_label_set_text(GTK_LABEL(smp_data->smp_progress_label),
-			_("Authentication successful."));
-	    } else {
-		gtk_label_set_text(GTK_LABEL(smp_data->smp_progress_label),
-			_("Your buddy has successfully authenticated you.  "
-			    "You may want to authenticate your buddy as "
-			    "well by asking your own question."));
-	    }
-        } else {
-	    gtk_label_set_text(GTK_LABEL(smp_data->smp_progress_label),
-		    _("Authentication failed."));
-	}
-    } else {
-	/* Clear the progress label */
-	gtk_label_set_text(GTK_LABEL(smp_data->smp_progress_label), "");
-    }
+/* Create the SMP dialog.  responder is true if this is called in
+ * response to someone else's run of SMP. */
+static void dialog_socialist_millionaires(ConnContext *context,
+	TCHAR *question, bool responder)
+{
+    if (context == NULL) return;
+	TCHAR primary[1024];
+
+    if (responder && question) {
+		(HANDLE)context->app_data
+        mir_sntprintf(primary, 1024, TranslateT(LANG_SMP_AUTH_FROM),
+            contact_get_nameT((HANDLE)context->app_data));
+    } else {
+        mir_sntprintf(primary, 1024, TranslateT(LANG_SMP_AUTH),
+            contact_get_nameT((HANDLE)context->app_data));
+    }
+    
+    /* fprintf(stderr, "Question = ``%s''\n", question); */
+	//TCHAR* proto_name = mir_a2t(context->protocol);
+	//if (!proto_name) proto_name = mir_tstrdup(TranslateT(LANG_UNKNOWN));
+    
+
+    dialog = create_smp_dialog(_("Authenticate Buddy"),
+	    primary, context, responder, question);
+
+    //mir_free(proto_name);
+}
+
+/* Call this to update the status of an ongoing socialist millionaires
+ * protocol.  Progress_level is a percentage, from 0.0 (aborted) to
+ * 1.0 (complete).  Any other value represents an intermediate state. */
+static void otrg_gtk_dialog_update_smp(ConnContext *context,
+	double progress_level)
+{
+    PurpleConversation *conv = otrg_plugin_context_to_conv(context, 0);
+    GtkProgressBar *bar;
+    SMPData *smp_data = purple_conversation_get_data(conv, "otr-smpdata");
+
+    if (!smp_data) return;
+
+    bar = GTK_PROGRESS_BAR(smp_data->smp_progress_bar);
+    gtk_progress_bar_set_fraction(bar, progress_level);
+
+    /* If the counter is reset to absolute zero, the protocol has aborted */
+    if (progress_level == 0.0) {
+        GtkDialog *dialog = GTK_DIALOG(smp_data->smp_progress_dialog);
+
+	gtk_dialog_set_response_sensitive(dialog, GTK_RESPONSE_ACCEPT, 1);
+	gtk_dialog_set_response_sensitive(dialog, GTK_RESPONSE_REJECT, 0);
+	gtk_dialog_set_default_response(GTK_DIALOG(dialog),
+		GTK_RESPONSE_ACCEPT);
+
+	gtk_label_set_text(GTK_LABEL(smp_data->smp_progress_label),
+		_("An error occurred during authentication."));
+	return;
+    } else if (progress_level == 1.0) {
+	/* If the counter reaches 1.0, the protocol is complete */
+        GtkDialog *dialog = GTK_DIALOG(smp_data->smp_progress_dialog);
+
+	gtk_dialog_set_response_sensitive(dialog, GTK_RESPONSE_ACCEPT, 1);
+	gtk_dialog_set_response_sensitive(dialog, GTK_RESPONSE_REJECT, 0);
+	gtk_dialog_set_default_response(GTK_DIALOG(dialog),
+		GTK_RESPONSE_ACCEPT);
+
+        if (context->smstate->sm_prog_state == OTRL_SMP_PROG_SUCCEEDED) {
+	    if (context->active_fingerprint->trust &&
+		    context->active_fingerprint->trust[0]) {
+		gtk_label_set_text(GTK_LABEL(smp_data->smp_progress_label),
+			_("Authentication successful."));
+	    } else {
+		gtk_label_set_text(GTK_LABEL(smp_data->smp_progress_label),
+			_("Your buddy has successfully authenticated you.  "
+			    "You may want to authenticate your buddy as "
+			    "well by asking your own question."));
+	    }
+        } else {
+	    gtk_label_set_text(GTK_LABEL(smp_data->smp_progress_label),
+		    _("Authentication failed."));
+	}
+    } else {
+	/* Clear the progress label */
+	gtk_label_set_text(GTK_LABEL(smp_data->smp_progress_label), "");
+    }
 }
\ No newline at end of file
Index: MirOTR/dllmain.cpp
===================================================================
--- MirOTR/dllmain.cpp	(revision 4)
+++ MirOTR/dllmain.cpp	(working copy)
@@ -12,6 +12,11 @@
 UTF8_INTERFACE utfi;
 char* g_metaproto;
 
+#ifdef _OTR_SEND_FILE
+pfnSHAutoComplete shAutoComplete;
+CLIST_INTERFACE *pcli;
+extern "C" void createTaskbarInterface(void);
+#endif
 
 PLUGININFOEX pluginInfo={
 	sizeof(PLUGININFOEX),
@@ -23,10 +28,15 @@
 	LEGAL_COPYRIGHT_LONG,
 	HOMEPAGE,
 	UNICODE_AWARE,		//not transient
-	0,		//doesn't replace anything built-in
+#ifdef _OTR_SEND_FILE
+	DEFMOD_SRFILE,		// replaces sr file mod (OTR_SEND FILE)
+#else
+	0,
+#endif
     MIID_OTRPLUGIN  // ANSI and Unicode have different IDs
 };
 
+
 BOOL APIENTRY DllMain( HMODULE hModule,
                        DWORD  ul_reason_for_call,
                        LPVOID lpReserved
@@ -34,6 +44,9 @@
 {
 	if (ul_reason_for_call == DLL_PROCESS_ATTACH) {
 		hInst=hModule;
+#ifdef _OTR_SEND_FILE
+        shAutoComplete = (pfnSHAutoComplete)GetProcAddress(GetModuleHandleA("shlwapi"),"SHAutoComplete");
+#endif
 		OTRL_INIT;
 		INITCOMMONCONTROLSEX icce = {0};
 		icce.dwSize = sizeof(icce);
@@ -175,6 +188,11 @@
 	CreateServiceFunction(MS_OTR_MENUREFRESH, SVC_RefreshOTR);
 	CreateServiceFunction(MS_OTR_MENUVERIFY, SVC_VerifyOTR);
 
+#ifdef _OTR_SEND_FILE
+    createTaskbarInterface();
+    pcli = (CLIST_INTERFACE*)CallService(MS_CLIST_RETRIEVE_INTERFACE, 0, (LPARAM)hInst);
+    LoadSendRecvFileModule();
+#endif
 	// hook modules loaded for updater support
 	HookEvent(ME_SYSTEM_MODULESLOADED, ModulesLoaded);
 	
Index: MirOTR/file.cpp
===================================================================
--- MirOTR/file.cpp	(revision 0)
+++ MirOTR/file.cpp	(revision 0)
@@ -0,0 +1,786 @@
+/*
+
+Miranda IM: the free IM client for Microsoft* Windows*
+
+Copyright 2000-2009 Miranda ICQ/IM project,
+all portions of this codebase are copyrighted to the people
+listed in contributors.txt.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+*/
+#ifdef _OTR_SEND_FILE
+#include "stdafx.h"
+
+TCHAR* PFTS_StringToTchar( int flags, const PROTOCHAR* s );
+int PFTS_CompareWithTchar( PROTOFILETRANSFERSTATUS* ft, const PROTOCHAR* s, TCHAR* r );
+
+static HANDLE hSRFileMenuItem;
+
+/* number of following bytes in sequence based on first byte value (for bytes above 0x7f) */
+static const char utf8_length[128] =
+{
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 0x80-0x8f */
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 0x90-0x9f */
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 0xa0-0xaf */
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 0xb0-0xbf */
+    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 0xc0-0xcf */
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 0xd0-0xdf */
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, /* 0xe0-0xef */
+    3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0  /* 0xf0-0xff */
+};
+
+/* first byte mask depending on UTF-8 sequence length */
+static const unsigned char utf8_mask[4] = { 0x7f, 0x1f, 0x0f, 0x07 };
+
+/* minimum Unicode value depending on UTF-8 sequence length */
+static const unsigned int utf8_minval[4] = { 0x0, 0x80, 0x800, 0x10000 };
+
+/* get the next char value taking surrogates into account */
+static unsigned int getSurrogateValue(const wchar_t *src, unsigned int srclen)
+{
+    if (src[0] >= 0xd800 && src[0] <= 0xdfff)  /* surrogate pair */
+    {
+        if (src[0] > 0xdbff || /* invalid high surrogate */
+            srclen <= 1 ||     /* missing low surrogate */
+            src[1] < 0xdc00 || src[1] > 0xdfff) /* invalid low surrogate */
+            return 0;
+        return 0x10000 + ((src[0] & 0x3ff) << 10) + (src[1] & 0x3ff);
+    }
+    return src[0];
+}
+
+/* helper for the various utf8 mbstowcs functions */
+static unsigned int decodeUtf8Char(unsigned char ch, const char **str, const char *strend)
+{
+    unsigned int len = utf8_length[ch-0x80];
+    unsigned int res = ch & utf8_mask[len];
+    const char *end = *str + len;
+
+    if (end > strend) return ~0;
+    switch(len)
+    {
+    case 3:
+        if ((ch = end[-3] ^ 0x80) >= 0x40) break;
+        res = (res << 6) | ch;
+        (*str)++;
+    case 2:
+        if ((ch = end[-2] ^ 0x80) >= 0x40) break;
+        res = (res << 6) | ch;
+        (*str)++;
+    case 1:
+        if ((ch = end[-1] ^ 0x80) >= 0x40) break;
+        res = (res << 6) | ch;
+        (*str)++;
+        if (res < utf8_minval[len]) break;
+        return res;
+    }
+    return ~0;
+}
+
+/* UTF-8 to wide char string conversion */
+/* return -1 on dst buffer overflow, -2 on invalid input char */
+int Utf8toUcs2(const char *src, int srclen, wchar_t *dst, int dstlen)
+{
+    unsigned int res;
+    const char *srcend = src + srclen;
+    wchar_t *dstend = dst + dstlen;
+
+    while ((dst < dstend) && (src < srcend))
+    {
+        unsigned char ch = *src++;
+        if (ch < 0x80)  /* special fast case for 7-bit ASCII */
+        {
+            *dst++ = ch;
+            continue;
+        }
+        if ((res = decodeUtf8Char(ch, &src, srcend)) <= 0xffff)
+        {
+            *dst++ = res;
+        }
+        else if (res <= 0x10ffff)  /* we need surrogates */
+        {
+            if (dst == dstend - 1) return -1;  /* overflow */
+            res -= 0x10000;
+            *dst++ = 0xd800 | (res >> 10);
+            *dst++ = 0xdc00 | (res & 0x3ff);
+        }
+        else return -2;  /* bad char */
+        /* otherwise ignore it */
+    }
+    if (src < srcend) return -1;  /* overflow */
+    return dstlen - (dstend - dst);
+}
+
+/* query necessary dst length for src string */
+static inline int Utf8toUcs2Len(const char *src, int srclen)
+{
+    int ret = 0;
+    unsigned int res;
+    const char *srcend = src + srclen;
+
+    while (src < srcend)
+    {
+        unsigned char ch = *src++;
+        if (ch < 0x80)  /* special fast case for 7-bit ASCII */
+        {
+            ret++;
+            continue;
+        }
+        if ((res = decodeUtf8Char(ch, &src, srcend)) <= 0x10ffff)
+        {
+            if (res > 0xffff) ret++;
+            ret++;
+        }
+        else return -2;  /* bad char */
+        /* otherwise ignore it */
+    }
+    return ret;
+}
+
+wchar_t* Utf8DecodeUcs2(const char* str)
+{
+	if (str == NULL)
+		return NULL;
+
+	int len = (int)strlen(str);
+
+	int destlen = Utf8toUcs2Len(str, len);
+	if (destlen < 0) return NULL;
+
+	wchar_t* ucs2 = (wchar_t*)mir_alloc((destlen + 1) * sizeof(wchar_t));
+	if (ucs2 == NULL) return NULL;
+
+	if (Utf8toUcs2(str, len, ucs2, destlen) >= 0)
+	{
+		ucs2[destlen] = 0;
+		return ucs2;
+	}
+
+	mir_free(ucs2);
+
+	return NULL;
+}
+
+/* wide char to UTF-8 string conversion */
+/* return -1 on dst buffer overflow, -2 on invalid input char */
+int Ucs2toUtf8(const wchar_t *src, int srclen, char *dst, int dstlen)
+{
+    int len;
+
+    for (len = dstlen; srclen; srclen--, src++)
+    {
+        WCHAR ch = *src;
+        unsigned int val;
+
+        if (ch < 0x80)  /* 0x00-0x7f: 1 byte */
+        {
+            if (!len--) return -1;  /* overflow */
+            *dst++ = ch;
+            continue;
+        }
+
+        if (ch < 0x800)  /* 0x80-0x7ff: 2 bytes */
+        {
+            if ((len -= 2) < 0) return -1;  /* overflow */
+            dst[1] = 0x80 | (ch & 0x3f);
+            ch >>= 6;
+            dst[0] = 0xc0 | ch;
+            dst += 2;
+            continue;
+        }
+
+        if (!(val = getSurrogateValue(src, srclen)))
+        {
+            return -2;
+        }
+
+        if (val < 0x10000)  /* 0x800-0xffff: 3 bytes */
+        {
+            if ((len -= 3) < 0) return -1;  /* overflow */
+            dst[2] = 0x80 | (val & 0x3f);
+            val >>= 6;
+            dst[1] = 0x80 | (val & 0x3f);
+            val >>= 6;
+            dst[0] = 0xe0 | val;
+            dst += 3;
+        }
+        else   /* 0x10000-0x10ffff: 4 bytes */
+        {
+            if ((len -= 4) < 0) return -1;  /* overflow */
+            dst[3] = 0x80 | (val & 0x3f);
+            val >>= 6;
+            dst[2] = 0x80 | (val & 0x3f);
+            val >>= 6;
+            dst[1] = 0x80 | (val & 0x3f);
+            val >>= 6;
+            dst[0] = 0xf0 | val;
+            dst += 4;
+            src++;
+            srclen--;
+        }
+    }
+    return dstlen - len;
+}
+
+/* query necessary dst length for src string */
+static int Ucs2toUtf8Len(const wchar_t *src, unsigned int srclen)
+{
+    int len;
+    unsigned int val;
+
+    for (len = 0; srclen; srclen--, src++)
+    {
+        if (*src < 0x80)  /* 0x00-0x7f: 1 byte */
+        {
+            len++;
+            continue;
+        }
+        if (*src < 0x800)  /* 0x80-0x7ff: 2 bytes */
+        {
+            len += 2;
+            continue;
+        }
+        if (!(val = getSurrogateValue(src, srclen)))
+        {
+            return -2;
+        }
+        if (val < 0x10000)  /* 0x800-0xffff: 3 bytes */
+            len += 3;
+        else   /* 0x10000-0x10ffff: 4 bytes */
+        {
+            len += 4;
+            src++;
+            srclen--;
+        }
+    }
+    return len;
+}
+
+/////////////////////////////////////////////////////////////////////////////////////////
+// Utf8Encode - converts UCS2 string to the UTF8-encoded format
+
+char* Utf8EncodeUcs2(const wchar_t* src)
+{
+	if (src == NULL)
+		return NULL;
+
+	int len = (int)wcslen(src);
+
+	int destlen = Ucs2toUtf8Len(src, len);
+	if (destlen < 0) return NULL;
+
+	char* result = (char*)mir_alloc(destlen + 1);
+	if (result == NULL)
+		return NULL;
+
+	Ucs2toUtf8(src, len, result, destlen);
+	result[destlen] = 0;
+
+	return result;
+}
+
+TCHAR *GetContactID(HANDLE hContact)
+{
+	TCHAR *theValue = {0};
+	char *szProto = ( char* )CallService(MS_PROTO_GETCONTACTBASEPROTO, (WPARAM)hContact, 0);
+	if (DBGetContactSettingByte(hContact, szProto, "ChatRoom", 0) == 1) {
+		DBVARIANT dbv;
+		if (!DBGetContactSettingTString(hContact, szProto, "ChatRoomID", &dbv)) {
+			theValue = (TCHAR *)mir_tstrdup(dbv.ptszVal);
+			DBFreeVariant(&dbv);
+			return theValue;
+		}	}
+	else {
+		CONTACTINFO ci = {0};
+		ci.cbSize = sizeof(ci);
+		ci.hContact = hContact;
+		ci.szProto = szProto;
+		ci.dwFlag = CNF_UNIQUEID | CNF_TCHAR;
+		if (!CallService(MS_CONTACT_GETCONTACTINFO, 0, (LPARAM) & ci)) {
+			switch (ci.type) {
+			case CNFT_ASCIIZ:
+				return (TCHAR *)ci.pszVal;
+				break;
+			case CNFT_DWORD:
+				return _itot(ci.dVal, (TCHAR *)mir_alloc(sizeof(TCHAR)*32), 10);
+				break;
+			}	}	}
+	return NULL;
+}
+
+void Window_SetIcon_IcoLib(HWND hWnd, const char* iconId)
+{
+	SendMessage(hWnd, WM_SETICON, ICON_BIG,   ( LPARAM )LoadIcon( iconId, 1 ));
+	SendMessage(hWnd, WM_SETICON, ICON_SMALL, ( LPARAM )LoadIcon( iconId, 0 ));
+}
+
+void Window_FreeIcon_IcoLib(HWND hWnd)
+{
+	ReleaseIcon(( HICON )SendMessage(hWnd, WM_SETICON, ICON_BIG, 0), 0);
+	ReleaseIcon(( HICON )SendMessage(hWnd, WM_SETICON, ICON_SMALL, 0), 0);
+}
+
+void Button_SetIcon_IcoLib(HWND hwndDlg, int itemId, const char* iconId, const char* tooltip)
+{
+	HWND hWnd = GetDlgItem( hwndDlg, itemId );
+	SendMessage( hWnd, BM_SETIMAGE, IMAGE_ICON, ( LPARAM )LoadIcon( iconId, 0 ));
+	SendMessage( hWnd, BUTTONSETASFLATBTN, 0, 0 );
+	SendMessage( hWnd, BUTTONADDTOOLTIP, (WPARAM)tooltip, 0);
+}
+
+void Button_FreeIcon_IcoLib(HWND hwndDlg, int itemId)
+{
+	HICON hIcon = ( HICON )SendDlgItemMessage(hwndDlg, itemId, BM_SETIMAGE, IMAGE_ICON, 0 );
+	ReleaseIcon(hIcon,0);
+}
+
+void List_Destroy( SortedList* p_list )
+{
+	if ( p_list == NULL )
+		return;
+
+	if ( p_list->items != NULL ) {
+		mir_free( p_list->items );
+		p_list->items = NULL;
+	}
+
+	p_list->realCount = p_list->limit = 0;
+}
+
+int List_Remove( SortedList* p_list, int index )
+{
+	if ( index < 0 || index > p_list->realCount )
+		return(0);
+
+   p_list->realCount--;
+   if ( p_list->realCount > index )
+	{
+		memmove( p_list->items+index, p_list->items+index+1, sizeof( void* )*( p_list->realCount-index ));
+      p_list->items[ p_list->realCount ] = NULL;
+	}
+
+   return 1;
+}
+
+int List_Insert( SortedList* p_list, void* p_value, int p_index) 
+{
+	if ( p_value == NULL || p_index > p_list->realCount )
+		return 0;
+
+   if ( p_list->realCount == p_list->limit )
+	{
+		p_list->items = ( void** )mir_realloc( p_list->items, sizeof( void* )*(p_list->realCount + p_list->increment));
+		p_list->limit += p_list->increment;
+	}
+
+	if ( p_index < p_list->realCount )
+		memmove( p_list->items+p_index+1, p_list->items+p_index, sizeof( void* )*( p_list->realCount-p_index ));
+
+   p_list->realCount++;
+
+   p_list->items[ p_index ] = p_value;
+   return 1;
+}
+
+SortedList* List_Create( int p_limit, int p_increment )
+{
+	SortedList* result = ( SortedList* )mir_calloc( sizeof( SortedList ));
+	if ( result == NULL )
+		return(NULL);
+
+	result->increment = p_increment;
+	result->limit = p_limit;
+	return(result);
+}
+
+#ifdef _UNICODE
+int CreateDirectoryTreeW( const WCHAR* szDir )
+{
+	DWORD  dwAttributes;
+	WCHAR* pszLastBackslash, szTestDir[ MAX_PATH ];
+
+	lstrcpynW( szTestDir, szDir, SIZEOF( szTestDir ));
+	if (( dwAttributes = GetFileAttributesW( szTestDir )) != INVALID_FILE_ATTRIBUTES && ( dwAttributes & FILE_ATTRIBUTE_DIRECTORY ))
+		return ERROR_ACCESS_DENIED;
+
+	pszLastBackslash = wcsrchr( szTestDir, '\\' );
+	if ( pszLastBackslash == NULL )
+		return 0;
+
+	*pszLastBackslash = '\0';
+	CreateDirectoryTreeW( szTestDir );
+	*pszLastBackslash = '\\';
+	return ( CreateDirectoryW( szTestDir, NULL ) == 0 ) ? GetLastError() : 0;
+}
+#endif
+
+struct FORK_ARG {
+	HANDLE hEvent;
+	pThreadFunc threadcode;
+	pThreadFuncEx threadcodeex;
+	void *arg, *owner;
+};
+
+/////////////////////////////////////////////////////////////////////////////////////////
+// exception handling
+
+static DWORD __cdecl sttDefaultFilter( DWORD, EXCEPTION_POINTERS* )
+{
+	return EXCEPTION_EXECUTE_HANDLER;
+}
+
+pfnExceptionFilter pMirandaExceptFilter = sttDefaultFilter;
+
+/////////////////////////////////////////////////////////////////////////////////////////
+// forkthread - starts a new thread
+
+void __cdecl forkthread_r(void * arg)
+{
+	struct FORK_ARG * fa = (struct FORK_ARG *) arg;
+	void (*callercode)(void*)=fa->threadcode;
+	void * cookie=fa->arg;
+	CallService(MS_SYSTEM_THREAD_PUSH,0,(LPARAM)callercode);
+	SetEvent(fa->hEvent);
+	__try
+	{
+		callercode(cookie);
+	}
+	__except( pMirandaExceptFilter( GetExceptionCode(), GetExceptionInformation()))
+	{
+		throw "Unhandled exception in thread";
+	}
+
+	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
+	CallService(MS_SYSTEM_THREAD_POP,0,0);
+	return;
+}
+
+UINT_PTR forkthread (
+	void (__cdecl *threadcode)(void*),
+	unsigned long stacksize,
+	void *arg
+)
+{
+	UINT_PTR rc;
+	struct FORK_ARG fa;
+	fa.hEvent=CreateEvent(NULL,FALSE,FALSE,NULL);
+	fa.threadcode=threadcode;
+	fa.arg=arg;
+	rc=_beginthread(forkthread_r,stacksize,&fa);
+	if ((UINT_PTR)-1L != rc)
+		WaitForSingleObject(fa.hEvent,INFINITE);
+
+	CloseHandle(fa.hEvent);
+	return rc;
+}
+
+int SVC_SendFileOTR(WPARAM wParam, LPARAM)
+{
+	struct FileSendData fsd;
+	fsd.hContact=(HANDLE)wParam;
+	fsd.ppFiles=NULL;
+	CreateDialogParam(hInst,MAKEINTRESOURCE(IDD_FILESEND),NULL,DlgProcSendFile,(LPARAM)&fsd);
+	return 0;
+}
+
+int SVC_RecvFileOTR(WPARAM, LPARAM lParam)
+{
+	CreateDialogParam(hInst,MAKEINTRESOURCE(IDD_FILERECV),NULL,DlgProcRecvFile,lParam);
+	return 0;
+}
+
+DLLFUNC void PushFileEvent( HANDLE hContact, HANDLE hdbe, LPARAM lParam )
+{
+	CLISTEVENT cle={0};
+	cle.cbSize = sizeof(cle);
+	cle.hContact = hContact;
+	cle.hDbEvent = hdbe;
+	cle.lParam = lParam;
+
+	if ( DBGetContactSettingByte(NULL,"SRFile","AutoAccept",0) && !DBGetContactSettingByte(hContact,"CList","NotOnList",0)) {
+		CreateDialogParam(hInst,MAKEINTRESOURCE(IDD_FILERECV),NULL,DlgProcRecvFile,(LPARAM)&cle);
+	}
+	else {
+		SkinPlaySound("RecvFile");
+
+		TCHAR szTooltip[256];
+		mir_sntprintf(szTooltip,SIZEOF(szTooltip),TranslateT("File from %s"), pcli->pfnGetContactDisplayName( hContact, 0 ));
+		cle.ptszTooltip = szTooltip;
+
+		cle.flags |= CLEF_TCHAR;
+		cle.hIcon = LoadIcon( "core_main_3", 0 ); // event file icon
+		cle.pszService = MS_OTR_MENURECVFILE;
+		CallService(MS_CLIST_ADDEVENT,0,(LPARAM)&cle);
+}	}
+
+static int FileEventAdded(WPARAM wParam,LPARAM lParam)
+{
+	DWORD dwSignature;
+
+	DBEVENTINFO dbei={0};
+	dbei.cbSize = sizeof(dbei);
+	dbei.cbBlob = sizeof( DWORD );
+	dbei.pBlob = ( PBYTE )&dwSignature;
+	CallService( MS_DB_EVENT_GET, lParam, ( LPARAM )&dbei );
+
+	if ( dbei.flags&(DBEF_SENT|DBEF_READ) || dbei.eventType != EVENTTYPE_FILE || dwSignature == 0 )
+		return 0;
+
+	PushFileEvent(( HANDLE )wParam, ( HANDLE )lParam, 0 );
+	return 0;
+}
+
+int SRFile_GetRegValue(HKEY hKeyBase,const TCHAR *szSubKey,const TCHAR *szValue,TCHAR *szOutput,int cbOutput)
+{
+	HKEY hKey;
+	DWORD cbOut=cbOutput;
+
+	if ( RegOpenKeyEx( hKeyBase,szSubKey,0,KEY_QUERY_VALUE,&hKey ) != ERROR_SUCCESS)
+		return 0;
+	
+	if ( RegQueryValueEx( hKey,szValue,NULL,NULL,(PBYTE)szOutput, &cbOut ) != ERROR_SUCCESS ) {
+		RegCloseKey(hKey);
+		return 0;
+	}
+
+	RegCloseKey(hKey);
+	return 1;
+}
+
+void GetSensiblyFormattedSize(__int64 size,TCHAR *szOut,int cchOut,int unitsOverride,int appendUnits,int *unitsUsed)
+{
+	if(!unitsOverride) {
+		if(size<1000) unitsOverride=UNITS_BYTES;
+		else if(size<100*1024) unitsOverride=UNITS_KBPOINT1;
+		else if(size<1024*1024) unitsOverride=UNITS_KBPOINT0;
+		else if(size<1024*1024*1024) unitsOverride=UNITS_MBPOINT2;
+    else unitsOverride=UNITS_GBPOINT3;
+	}
+	if(unitsUsed) *unitsUsed=unitsOverride;
+	switch(unitsOverride) {
+		case UNITS_BYTES: mir_sntprintf(szOut,cchOut,_T("%u%s%s"),(int)size,appendUnits?_T(" "):_T(""),appendUnits?TranslateT("bytes"):_T("")); break;
+		case UNITS_KBPOINT1: mir_sntprintf(szOut,cchOut,_T("%.1lf%s"),size/1024.0,appendUnits?_T(" KB"):_T("")); break;
+		case UNITS_KBPOINT0: mir_sntprintf(szOut,cchOut,_T("%u%s"),(int)(size/1024),appendUnits?_T(" KB"):_T("")); break;
+		case UNITS_GBPOINT3: mir_sntprintf(szOut,cchOut,_T("%.3f%s"),(size >> 20)/1024.0,appendUnits?_T(" GB"):_T("")); break;
+		default: mir_sntprintf(szOut,cchOut,_T("%.2lf%s"),size/1048576.0,appendUnits?_T(" MB"):_T("")); break;
+	}
+}
+
+// Tripple redirection sucks but is needed to nullify the array pointer
+void FreeFilesMatrix(TCHAR ***files)
+{
+	if (*files == NULL)
+		return;
+
+	// Free each filename in the pointer array
+	TCHAR **pFile = *files;
+	while (*pFile != NULL)
+	{
+		mir_free(*pFile);
+		*pFile = NULL;
+		pFile++;
+	}
+
+	// Free the array itself
+	mir_free(*files);
+	*files = NULL;
+}
+
+void FreeProtoFileTransferStatus(PROTOFILETRANSFERSTATUS *fts)
+{
+	mir_free(fts->tszCurrentFile);
+	if(fts->ptszFiles) {
+		for( int i=0;i<fts->totalFiles;i++) mir_free(fts->ptszFiles[i]);
+		mir_free(fts->ptszFiles);
+	}
+	mir_free(fts->tszWorkingDir);
+}
+
+void CopyProtoFileTransferStatus(PROTOFILETRANSFERSTATUS *dest, PROTOFILETRANSFERSTATUS *src)
+{
+	*dest=*src;
+	if ( src->tszCurrentFile ) dest->tszCurrentFile = PFTS_StringToTchar(src->flags, src->tszCurrentFile);
+	if ( src->ptszFiles ) {
+		dest->ptszFiles = (TCHAR**)mir_alloc(sizeof(TCHAR*)*src->totalFiles);
+		for( int i=0; i < src->totalFiles; i++ )
+			dest->ptszFiles[i] = PFTS_StringToTchar(src->flags, src->ptszFiles[i] );
+	}
+	if ( src->tszWorkingDir ) dest->tszWorkingDir = PFTS_StringToTchar(src->flags, src->tszWorkingDir );
+	dest->flags &= ~PFTS_UTF;
+	dest->flags |= PFTS_TCHAR;
+}
+
+void UpdateProtoFileTransferStatus(PROTOFILETRANSFERSTATUS *dest, PROTOFILETRANSFERSTATUS *src)
+{
+	if (src->cbSize == sizeof(PROTOFILETRANSFERSTATUS_V1))
+	{
+		PROTOFILETRANSFERSTATUS_V1 *src1 = (PROTOFILETRANSFERSTATUS_V1*)src;
+		src = (PROTOFILETRANSFERSTATUS*)alloca(sizeof(PROTOFILETRANSFERSTATUS));
+
+		src->cbSize               = sizeof(PROTOFILETRANSFERSTATUS);
+		src->hContact             = src1->hContact;
+		src->flags                = src1->sending ? PFTS_SENDING : 0;
+		src->pszFiles             = src1->files;
+		src->totalFiles           = src1->totalFiles;
+		src->currentFileNumber    = src1->currentFileNumber;
+		src->totalBytes           = src1->totalBytes;
+		src->totalProgress        = src1->totalProgress;
+		src->szWorkingDir         = src1->workingDir;
+		src->szCurrentFile        = src1->currentFile;
+		src->currentFileSize      = src1->currentFileSize;
+		src->currentFileProgress  = src1->currentFileProgress;
+		src->currentFileTime      = src1->currentFileTime;
+	}
+
+	dest->hContact = src->hContact;
+	dest->flags = src->flags;
+	if ( dest->totalFiles != src->totalFiles ) {
+		for( int i=0;i<dest->totalFiles;i++) mir_free(dest->ptszFiles[i]);
+		mir_free(dest->ptszFiles);
+		dest->ptszFiles = NULL;
+		dest->totalFiles = src->totalFiles;
+	}
+	if ( src->ptszFiles ) {
+		if ( !dest->ptszFiles )
+			dest->ptszFiles = ( TCHAR** )mir_calloc( sizeof(TCHAR*)*src->totalFiles);
+		for ( int i=0; i < src->totalFiles; i++ )
+			if ( !dest->ptszFiles[i] || !src->ptszFiles[i] || PFTS_CompareWithTchar( src, src->ptszFiles[i], dest->ptszFiles[i] )) {
+				mir_free( dest->ptszFiles[i] );
+				if ( src->ptszFiles[i] )
+					dest->ptszFiles[i] = PFTS_StringToTchar( src->flags, src->ptszFiles[i] );
+				else
+					dest->ptszFiles[i] = NULL;
+			}
+	}
+	else if (dest->ptszFiles) {
+		for( int i=0; i < dest->totalFiles; i++ )
+			mir_free(dest->ptszFiles[i]);
+		mir_free( dest->ptszFiles );
+		dest->ptszFiles = NULL;
+	}
+
+	dest->currentFileNumber = src->currentFileNumber;
+	dest->totalBytes = src->totalBytes;
+	dest->totalProgress = src->totalProgress;
+	if (src->tszWorkingDir && (!dest->tszWorkingDir || PFTS_CompareWithTchar( src, src->tszWorkingDir, dest->tszWorkingDir))) {
+		mir_free( dest->tszWorkingDir );
+		if ( src->tszWorkingDir )
+			dest->tszWorkingDir = PFTS_StringToTchar( src->flags, src->tszWorkingDir );
+		else
+			dest->tszWorkingDir = NULL;
+	}
+
+	if ( !dest->tszCurrentFile || !src->tszCurrentFile || PFTS_CompareWithTchar( src, src->tszCurrentFile, dest->tszCurrentFile )) {
+		mir_free( dest->tszCurrentFile );
+		if ( src->tszCurrentFile )
+			dest->tszCurrentFile = PFTS_StringToTchar( src->flags, src->tszCurrentFile );
+		else
+			dest->tszCurrentFile = NULL;
+	}
+	dest->currentFileSize = src->currentFileSize;
+	dest->currentFileProgress = src->currentFileProgress;
+	dest->currentFileTime = src->currentFileTime;
+  dest->flags &= ~PFTS_UTF;
+  dest->flags |= PFTS_TCHAR;
+}
+
+static void RemoveUnreadFileEvents(void)
+{
+	DBEVENTINFO dbei={0};
+	HANDLE hDbEvent,hContact;
+
+	dbei.cbSize=sizeof(dbei);
+	hContact=(HANDLE)CallService(MS_DB_CONTACT_FINDFIRST,0,0);
+	while(hContact) {
+		hDbEvent=(HANDLE)CallService(MS_DB_EVENT_FINDFIRSTUNREAD,(WPARAM)hContact,0);
+		while(hDbEvent) {
+			dbei.cbBlob=0;
+			CallService(MS_DB_EVENT_GET,(WPARAM)hDbEvent,(LPARAM)&dbei);
+			if(!(dbei.flags&(DBEF_SENT|DBEF_READ)) && dbei.eventType==EVENTTYPE_FILE)
+				CallService(MS_DB_EVENT_MARKREAD,(WPARAM)hContact,(LPARAM)hDbEvent);
+			hDbEvent=(HANDLE)CallService(MS_DB_EVENT_FINDNEXT,(WPARAM)hDbEvent,0);
+		}
+		hContact=(HANDLE)CallService(MS_DB_CONTACT_FINDNEXT,(WPARAM)hContact,0);
+	}
+}
+
+static int SRFilePreBuildMenu(WPARAM wParam, LPARAM)
+{
+	CLISTMENUITEM mi = { 0 };
+	mi.cbSize = sizeof(mi);
+	mi.flags = CMIM_FLAGS | CMIF_HIDDEN;
+
+	char *szProto = (char*)CallService(MS_PROTO_GETCONTACTBASEPROTO, wParam, 0);
+	if (szProto != NULL) {
+		if ( CallProtoService(szProto, PS_GETCAPS,PFLAGNUM_1, 0 ) & PF1_FILESEND) {
+			if ( CallProtoService(szProto, PS_GETCAPS,PFLAGNUM_4, 0 ) & PF4_OFFLINEFILES )
+				mi.flags = CMIM_FLAGS;
+			else if ( DBGetContactSettingWord(( HANDLE )wParam, szProto, "Status", ID_STATUS_OFFLINE ) != ID_STATUS_OFFLINE )
+				mi.flags = CMIM_FLAGS;
+	}	}
+
+	CallService(MS_CLIST_MODIFYMENUITEM, (WPARAM)hSRFileMenuItem, (LPARAM)&mi);
+	return 0;
+}
+
+static int SRFileModulesLoaded(WPARAM, LPARAM)
+{
+	CLISTMENUITEM mi = { 0 };
+	mi.cbSize = sizeof(mi);
+	mi.position = -2000020000;
+	mi.icolibItem = GetIconHandle("core_main_3"); // event file
+	mi.pszName = LPGEN("&Encrypted File");
+	mi.pszService = MS_OTR_MENUSENDFILE;
+	mi.flags = CMIF_ICONFROMICOLIB;
+	hSRFileMenuItem = ( HANDLE )CallService(MS_CLIST_ADDCONTACTMENUITEM,0,(LPARAM)&mi);
+
+	RemoveUnreadFileEvents();
+	return 0;
+}
+
+INT_PTR FtMgrShowCommand(WPARAM, LPARAM)
+{
+	FtMgr_Show(true, true);
+	return 0;
+}
+
+int LoadSendRecvFileModule(void)
+{
+	CreateServiceFunction("EFtMgr/Show", FtMgrShowCommand);
+
+	CLISTMENUITEM mi = { 0 };
+	mi.cbSize = sizeof(mi);
+	mi.flags = CMIF_ICONFROMICOLIB;
+	mi.icolibItem = GetIconHandle("core_main_3"); // event file
+	mi.position = 1900000000;
+	mi.pszName = LPGEN("Encr&ypted File Transfers...");
+	mi.pszService = "EFtMgr/Show"; //MS_PROTO_SHOWFTMGR;
+	CallService( MS_CLIST_ADDMAINMENUITEM, 0, ( LPARAM )&mi );
+
+	HookEvent(ME_SYSTEM_MODULESLOADED,SRFileModulesLoaded);
+	HookEvent(ME_DB_EVENT_ADDED,FileEventAdded);
+	HookEvent(ME_OPT_INITIALISE,FileOptInitialise);
+	HookEvent(ME_CLIST_PREBUILDCONTACTMENU, SRFilePreBuildMenu);
+
+	CreateServiceFunction(MS_OTR_MENUSENDFILE, SVC_SendFileOTR);
+	CreateServiceFunction(MS_OTR_MENURECVFILE, SVC_RecvFileOTR);
+
+	SkinAddNewSoundEx("RecvFile",   "File", "Incoming");
+	SkinAddNewSoundEx("FileDone",   "File", "Complete");
+	SkinAddNewSoundEx("FileFailed", "File", "Error");
+	SkinAddNewSoundEx("FileDenied", "File", "Denied");
+	return 0;
+}
+#endif
\ No newline at end of file
Index: MirOTR/file.h
===================================================================
--- MirOTR/file.h	(revision 0)
+++ MirOTR/file.h	(revision 0)
@@ -0,0 +1,118 @@
+/*
+
+Miranda IM: the free IM client for Microsoft* Windows*
+
+Copyright 2000-2009 Miranda ICQ/IM project, 
+all portions of this codebase are copyrighted to the people 
+listed in contributors.txt.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+*/
+#ifdef _OTR_SEND_FILE
+#define VIRUSSCAN_DISABLE  0
+#define VIRUSSCAN_AFTERDL  1
+#define VIRUSSCAN_DURINGDL 2
+
+#define FILERESUME_ASK         0
+//1,2,3,4: resume, overwrite, rename, skip: from proto library
+#define FILERESUMEF_ALL         0x80
+#define FILERESUME_RESUMEALL    (FILERESUME_RESUME|FILERESUMEF_ALL)
+#define FILERESUME_OVERWRITEALL (FILERESUME_OVERWRITE|FILERESUMEF_ALL)
+#define FILERESUME_RENAMEALL    (FILERESUME_RENAME|FILERESUMEF_ALL)
+#define FILERESUME_CANCEL       0xFFFFFFFF
+
+#define M_FILEEXISTSDLGREPLY   (WM_USER+200)
+#define M_PRESHUTDOWN		   (WM_USER+201)
+
+extern int LoadSendRecvFileModule(void);
+
+struct FileSendData {
+	HANDLE hContact;
+	const TCHAR **ppFiles;
+};
+
+#define BYTESRECVEDHISTORYCOUNT  10   //the number of bytes recved is sampled once a second and the last 10 are used to get the transfer speed
+struct FileDlgData {
+	HWND hwndTransfer;
+	HANDLE fs;
+	HANDLE hContact;
+	HANDLE hDbEvent;
+	HANDLE hNotifyEvent;
+	TCHAR **files;
+	int send;
+	int closeIfFileChooseCancelled;
+	int resumeBehaviour;
+	int bytesRecvedHistory[BYTESRECVEDHISTORYCOUNT];
+	int bytesRecvedHistorySize;
+	int waitingForAcceptance;
+	PROTOFILETRANSFERSTATUS transferStatus;
+	int *fileVirusScanned;
+	HANDLE hPreshutdownEvent;
+	DWORD dwTicks;
+
+	TCHAR szSavePath[MAX_PATH];
+	TCHAR szMsg[450], szFilenames[1024];
+	HICON hIcon, hIconFolder;
+};
+
+//file.c
+#define UNITS_BYTES     1   // 0<=size<1000: "%d bytes"
+#define UNITS_KBPOINT1	2	// 1000<=size<100*1024: "%.1f KB"
+#define UNITS_KBPOINT0  3   // 100*1024<=size<1024*1024: "%d KB"
+#define UNITS_MBPOINT2  4   // 1024*1024<=size: "%.2f MB"
+#define UNITS_GBPOINT3  5   // 1024*1024*1024<=size: "%.3f GB"
+
+void GetSensiblyFormattedSize(__int64 size,TCHAR *szOut,int cchOut,int unitsOverride,int appendUnits,int *unitsUsed);
+void FreeFilesMatrix(TCHAR ***files);	  //loving that triple indirection
+void FreeProtoFileTransferStatus(PROTOFILETRANSFERSTATUS *fts);
+void CopyProtoFileTransferStatus(PROTOFILETRANSFERSTATUS *dest,PROTOFILETRANSFERSTATUS *src);
+void UpdateProtoFileTransferStatus(PROTOFILETRANSFERSTATUS *dest,PROTOFILETRANSFERSTATUS *src);
+int SRFile_GetRegValue(HKEY hKeyBase,const TCHAR *szSubKey,const TCHAR *szValue,TCHAR *szOutput,int cbOutput);
+//filesenddlg.c
+INT_PTR CALLBACK DlgProcSendFile(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
+//filerecv.c
+INT_PTR CALLBACK DlgProcRecvFile(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
+void RemoveInvalidFilenameChars(TCHAR *tszString);
+void RemoveInvalidPathChars(TCHAR *tszString);
+void GetContactReceivedFilesDir(HANDLE hContact,TCHAR *szDir,int cchDir,BOOL substVars);
+void GetReceivedFilesDir(TCHAR *szDir,int cchDir);
+int BrowseForFolder(HWND hwnd,TCHAR *szPath);
+//fileexistsdlg.c
+struct TDlgProcFileExistsParam
+{
+	HWND hwndParent;
+	PROTOFILETRANSFERSTATUS *fts;
+};
+INT_PTR CALLBACK DlgProcFileExists(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
+//filexferdlg.c
+INT_PTR CALLBACK DlgProcFileTransfer(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
+//fileopts.c
+int FileOptInitialise(WPARAM wParam,LPARAM lParam);
+//ftmanager.c
+#define WM_FT_ADD			(WM_USER+701)
+#define WM_FT_RESIZE		(WM_USER+702)
+#define WM_FT_REMOVE		(WM_USER+703)
+#define WM_FT_SELECTPAGE	(WM_USER+704)
+#define WM_FT_CLEANUP		(WM_USER+705)
+#define WM_FT_COMPLETED		(WM_USER+706)
+
+HWND FtMgr_Show(bool bForceActivate, bool bFromMenu);
+void FtMgr_Destroy();
+HWND FtMgr_AddTransfer(struct FileDlgData *dat);
+
+void FreeFileDlgData( FileDlgData* dat );
+
+TCHAR *GetContactID(HANDLE hContact);
+#endif
\ No newline at end of file
Index: MirOTR/fileexistsdlg.cpp
===================================================================
--- MirOTR/fileexistsdlg.cpp	(revision 0)
+++ MirOTR/fileexistsdlg.cpp	(revision 0)
@@ -0,0 +1,352 @@
+/*
+
+Miranda IM: the free IM client for Microsoft* Windows*
+
+Copyright 2000-2009 Miranda ICQ/IM project, 
+all portions of this codebase are copyrighted to the people 
+listed in contributors.txt.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+*/
+#ifdef _OTR_SEND_FILE
+#include "stdafx.h"
+
+static void SetControlToUnixTime(HWND hwndDlg, UINT idCtrl, time_t unixTime)
+{
+	LARGE_INTEGER liFiletime;
+	FILETIME filetime;
+	SYSTEMTIME st;
+	char szTime[64],szDate[64],szOutput[128];
+
+	liFiletime.QuadPart=(BIGI(11644473600)+(__int64)unixTime)*10000000;
+	filetime.dwHighDateTime=liFiletime.HighPart;
+	filetime.dwLowDateTime=liFiletime.LowPart;
+	FileTimeToSystemTime(&filetime,&st);
+	GetTimeFormatA(LOCALE_USER_DEFAULT,0,&st,NULL,szTime,SIZEOF(szTime));
+	GetDateFormatA(LOCALE_USER_DEFAULT,DATE_SHORTDATE,&st,NULL,szDate,SIZEOF(szDate));
+	mir_snprintf(szOutput, SIZEOF(szOutput), "%s %s",szDate,szTime);
+	SetDlgItemTextA(hwndDlg,idCtrl,szOutput);
+}
+
+#define C_CONTEXTMENU  0
+#define C_PROPERTIES   1
+// not defined in VC++ 6.0 SE
+#ifndef CMF_EXTENDEDVERBS
+#define CMF_EXTENDEDVERBS 0x00000100
+#endif
+static void DoAnnoyingShellCommand(HWND hwnd,const TCHAR *szFilename,int cmd,POINT *ptCursor)
+{
+	IShellFolder *pDesktopFolder;
+	if(SHGetDesktopFolder(&pDesktopFolder)==NOERROR) {
+		ITEMIDLIST *pCurrentIdl;
+		#if defined( _UNICODE )
+			WCHAR* wszFilename = ( LPWSTR )szFilename;
+		#else
+			WCHAR wszFilename[MAX_PATH];
+			MultiByteToWideChar(CP_ACP,0,szFilename,-1,wszFilename,SIZEOF(wszFilename));
+		#endif
+		if(pDesktopFolder->ParseDisplayName(NULL,NULL,wszFilename,NULL,&pCurrentIdl,NULL)==NOERROR) {
+			if(pCurrentIdl->mkid.cb) {
+				ITEMIDLIST *pidl,*pidlNext,*pidlFilename;
+				IShellFolder *pFileFolder;
+
+				for(pidl=pCurrentIdl;;) {
+					pidlNext=(ITEMIDLIST*)((PBYTE)pidl+pidl->mkid.cb);
+					if(pidlNext->mkid.cb==0) {
+						pidlFilename = (ITEMIDLIST*)CoTaskMemAlloc(pidl->mkid.cb+sizeof(pidl->mkid.cb));
+						CopyMemory(pidlFilename,pidl,pidl->mkid.cb+sizeof(pidl->mkid.cb));
+						pidl->mkid.cb=0;
+						break;
+					}
+					pidl=pidlNext;
+				}
+				if(pDesktopFolder->BindToObject(pCurrentIdl,NULL,IID_IShellFolder,(void**)&pFileFolder)==NOERROR) {
+					IContextMenu *pContextMenu;
+					if(pFileFolder->GetUIObjectOf(NULL,1,(LPCITEMIDLIST*)&pidlFilename,IID_IContextMenu,NULL,(void**)&pContextMenu)==NOERROR) {
+						switch(cmd) {
+							case C_PROPERTIES:
+							{	CMINVOKECOMMANDINFO ici={0};
+								ici.cbSize=sizeof(ici);
+								ici.hwnd=hwnd;
+								ici.lpVerb="properties";
+								ici.nShow=SW_SHOW;
+								pContextMenu->InvokeCommand(&ici);
+								break;
+							}
+							case C_CONTEXTMENU:
+							{	HMENU hMenu;
+								hMenu=CreatePopupMenu();
+								if(SUCCEEDED(pContextMenu->QueryContextMenu(hMenu,0,1000,65535,(GetKeyState(VK_SHIFT)&0x8000?CMF_EXTENDEDVERBS:0)|CMF_NORMAL))) {
+									int cmd;
+									cmd=TrackPopupMenu(hMenu,TPM_RETURNCMD,ptCursor->x,ptCursor->y,0,hwnd,NULL);
+									if(cmd) {
+										CMINVOKECOMMANDINFO ici={0};
+										ici.cbSize=sizeof(ici);
+										ici.hwnd=hwnd;
+										ici.lpVerb=MAKEINTRESOURCEA(cmd-1000);
+										ici.nShow=SW_SHOW;
+										pContextMenu->InvokeCommand(&ici);
+									}
+								}
+								DestroyMenu(hMenu);
+								break;
+							}
+						}
+						pContextMenu->Release();
+					}
+					pFileFolder->Release();
+				}
+				CoTaskMemFree(pidlFilename);
+			}
+			CoTaskMemFree(pCurrentIdl);
+		}
+		pDesktopFolder->Release();
+	}
+}
+
+static WNDPROC pfnIconWindowProc;
+static LRESULT CALLBACK IconCtrlSubclassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
+{
+	PROTOFILETRANSFERSTATUS* pft = (PROTOFILETRANSFERSTATUS*)GetWindowLongPtr(GetParent(hwnd),GWLP_USERDATA);
+
+	switch(msg) {
+		case WM_LBUTTONDBLCLK:
+			ShellExecute(hwnd,NULL,pft->tszCurrentFile,NULL,NULL,SW_SHOW);
+			break;
+		case WM_RBUTTONUP:
+		{	POINT pt;
+			pt.x=(short)LOWORD(lParam); pt.y=(short)HIWORD(lParam);
+			ClientToScreen( hwnd, &pt );
+			DoAnnoyingShellCommand( hwnd, pft->tszCurrentFile, C_CONTEXTMENU, &pt );
+			return 0;
+		}
+	}
+	return CallWindowProc(pfnIconWindowProc,hwnd,msg,wParam,lParam);
+}
+
+struct loadiconsstartinfo {
+	HWND hwndDlg;
+	TCHAR *szFilename;
+};
+void __cdecl LoadIconsAndTypesThread(void* param)
+{
+	loadiconsstartinfo *info = ( loadiconsstartinfo* )param;
+	SHFILEINFO fileInfo;
+
+	if ( SHGetFileInfo( info->szFilename, 0, &fileInfo, sizeof(fileInfo),SHGFI_TYPENAME|SHGFI_ICON|SHGFI_LARGEICON)) {
+		TCHAR *pszExtension,*pszFilename;
+		TCHAR szExtension[64];
+		TCHAR szIconFile[MAX_PATH];
+
+		pszFilename = _tcsrchr(info->szFilename,'\\');
+		if ( pszFilename == NULL )
+			pszFilename = info->szFilename;
+
+		pszExtension = _tcsrchr( pszFilename, '.' );
+		if ( pszExtension )
+			lstrcpyn( szExtension, pszExtension+1, SIZEOF( szExtension ));
+		else {
+			pszExtension = _T(".");
+			szExtension[0]='\0';
+		}
+		CharUpper(szExtension);
+		if ( fileInfo.szTypeName[0]=='\0' )
+			mir_sntprintf( fileInfo.szTypeName, SIZEOF(fileInfo.szTypeName), TranslateT("%s File"),szExtension);
+		SetDlgItemText(info->hwndDlg,IDC_EXISTINGTYPE,fileInfo.szTypeName);
+		SetDlgItemText(info->hwndDlg,IDC_NEWTYPE,fileInfo.szTypeName);
+		SendDlgItemMessage(info->hwndDlg,IDC_EXISTINGICON,STM_SETICON,(WPARAM)fileInfo.hIcon,0);
+		szIconFile[0]='\0';
+		if ( !lstrcmp( szExtension, _T("EXE"))) {
+			SRFile_GetRegValue(HKEY_LOCAL_MACHINE,_T("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons"),_T("2"),szIconFile,SIZEOF(szIconFile));
+		}
+		else {
+			TCHAR szTypeName[MAX_PATH];
+			if(SRFile_GetRegValue(HKEY_CLASSES_ROOT,pszExtension,NULL,szTypeName,SIZEOF(szTypeName))) {
+				lstrcat(szTypeName,_T("\\DefaultIcon"));
+				if(SRFile_GetRegValue(HKEY_CLASSES_ROOT,szTypeName,NULL,szIconFile,SIZEOF(szIconFile))) {
+					if ( _tcsstr( szIconFile, _T("%1")))
+						SRFile_GetRegValue(HKEY_LOCAL_MACHINE,_T("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons"),_T("0"),szIconFile,SIZEOF(szIconFile));
+					else szIconFile[0]='\0';
+		}	}	}
+
+		if ( szIconFile[0]) {
+			int iconIndex;
+			HICON hIcon;
+			TCHAR *pszComma = _tcsrchr(szIconFile,',');
+			if ( pszComma == NULL )
+				iconIndex=0;
+			else {
+				iconIndex = _ttoi(pszComma+1); *pszComma='\0';
+			}
+			hIcon = ExtractIcon( hInst, szIconFile, iconIndex );
+			if ( hIcon )
+				fileInfo.hIcon = hIcon;
+		}
+		SendDlgItemMessage(info->hwndDlg,IDC_NEWICON,STM_SETICON,(WPARAM)fileInfo.hIcon,0);
+	}
+	mir_free(info->szFilename);
+	mir_free(info);
+}
+
+INT_PTR CALLBACK DlgProcFileExists(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
+{
+	PROTOFILETRANSFERSTATUS *fts;
+
+	fts=(PROTOFILETRANSFERSTATUS*)GetWindowLongPtr(hwndDlg,GWLP_USERDATA);
+	switch(msg) {
+	case WM_INITDIALOG:
+	{
+		TCHAR szSize[64];
+		struct _stati64 statbuf;
+		HWND hwndFocus;
+		struct TDlgProcFileExistsParam *dat = (struct TDlgProcFileExistsParam *)lParam;
+
+		SetPropA(hwndDlg,"Miranda.Preshutdown",HookEventMessage(ME_SYSTEM_PRESHUTDOWN,hwndDlg,M_PRESHUTDOWN));
+		SetPropA(hwndDlg,"Miranda.ParentWnd",dat->hwndParent);
+
+		TranslateDialogDefault(hwndDlg);
+		fts=(PROTOFILETRANSFERSTATUS*)mir_alloc(sizeof(PROTOFILETRANSFERSTATUS));
+		CopyProtoFileTransferStatus(fts,dat->fts);
+		SetWindowLongPtr(hwndDlg,GWLP_USERDATA,(LONG_PTR)fts);
+		SetDlgItemText(hwndDlg,IDC_FILENAME,fts->tszCurrentFile);
+		SetControlToUnixTime(hwndDlg,IDC_NEWDATE,fts->currentFileTime);
+		GetSensiblyFormattedSize(fts->currentFileSize,szSize,SIZEOF(szSize),0,1,NULL);
+		SetDlgItemText(hwndDlg,IDC_NEWSIZE,szSize);
+
+		pfnIconWindowProc=(WNDPROC)SetWindowLongPtr(GetDlgItem(hwndDlg,IDC_EXISTINGICON),GWLP_WNDPROC,(LONG_PTR)IconCtrlSubclassProc);
+
+		hwndFocus=GetDlgItem(hwndDlg,IDC_RESUME);
+		if ( _tstati64(fts->tszCurrentFile,&statbuf)==0) {
+			SetControlToUnixTime(hwndDlg,IDC_EXISTINGDATE,statbuf.st_mtime);
+			GetSensiblyFormattedSize(statbuf.st_size,szSize,SIZEOF(szSize),0,1,NULL);
+			SetDlgItemText(hwndDlg,IDC_EXISTINGSIZE,szSize);
+			if(statbuf.st_size>(int)fts->currentFileSize) {
+				EnableWindow(GetDlgItem(hwndDlg,IDC_RESUME),FALSE);
+				hwndFocus=GetDlgItem(hwndDlg,IDC_OVERWRITE);
+		}	}
+
+		loadiconsstartinfo *lisi = ( loadiconsstartinfo* )mir_alloc(sizeof(loadiconsstartinfo));
+		lisi->hwndDlg=hwndDlg;
+		lisi->szFilename = mir_tstrdup(fts->tszCurrentFile);
+		//can be a little slow, so why not?
+		forkthread(LoadIconsAndTypesThread,0,lisi);			
+		SetFocus(hwndFocus);
+		SetWindowLongPtr(hwndFocus,GWL_STYLE,GetWindowLongPtr(hwndFocus,GWL_STYLE)|BS_DEFPUSHBUTTON);
+		return FALSE;
+	}
+	case WM_COMMAND:
+	{	
+		PROTOFILERESUME pfr={0};
+		switch(LOWORD(wParam)) {
+		case IDC_OPENFILE:
+			ShellExecute( hwndDlg, NULL, fts->tszCurrentFile, NULL, NULL, SW_SHOW );
+			return FALSE;
+
+		case IDC_OPENFOLDER:
+		{	
+			TCHAR szFile[MAX_PATH];
+			lstrcpyn( szFile, fts->tszCurrentFile, SIZEOF(szFile));
+			TCHAR* pszLastBackslash = _tcsrchr( szFile, '\\' );
+			if ( pszLastBackslash )
+				*pszLastBackslash = '\0';
+			ShellExecute(hwndDlg,NULL,szFile,NULL,NULL,SW_SHOW);
+			return FALSE;
+		}
+		case IDC_PROPERTIES:
+			DoAnnoyingShellCommand(hwndDlg,fts->tszCurrentFile,C_PROPERTIES,NULL);
+			return FALSE;
+		case IDC_RESUME:
+			pfr.action=FILERESUME_RESUME;
+			break;
+		case IDC_RESUMEALL:
+			pfr.action=FILERESUME_RESUMEALL;
+			break;
+		case IDC_OVERWRITE:
+			pfr.action=FILERESUME_OVERWRITE;
+			break;
+		case IDC_OVERWRITEALL:
+			pfr.action=FILERESUME_OVERWRITEALL;
+			break;
+
+		case IDC_AUTORENAME:
+			pfr.action = FILERESUME_RENAMEALL;
+			break;
+
+		case IDC_SAVEAS:
+		{	
+			OPENFILENAME ofn={0};
+			TCHAR filter[512],*pfilter;
+			TCHAR str[MAX_PATH];
+
+			lstrcpyn( str, fts->tszCurrentFile, SIZEOF(str));
+			ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
+			ofn.hwndOwner = hwndDlg;
+			ofn.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY;
+			_tcscpy( filter, TranslateT("All Files"));
+			_tcscat( filter, _T(" (*)"));
+			pfilter = filter + _tcslen(filter) + 1;
+			_tcscpy( pfilter, _T("*"));
+			pfilter = pfilter + _tcslen(pfilter) + 1;
+			*pfilter='\0';
+			ofn.lpstrFilter = filter;
+			ofn.lpstrFile = str;
+			ofn.nMaxFile = SIZEOF(str);
+			ofn.nMaxFileTitle = MAX_PATH;
+			if(!GetSaveFileName(&ofn))
+				return FALSE;
+
+			pfr.szFilename = mir_tstrdup(str);
+			pfr.action = FILERESUME_RENAME;
+			break;
+		}
+		case IDC_SKIP:
+			pfr.action=FILERESUME_SKIP;
+			break;
+		case IDCANCEL:
+			pfr.action=FILERESUME_CANCEL;
+			break;
+		default:
+			return FALSE;
+		}
+		{	PROTOFILERESUME *pfrCopy;
+			pfrCopy=(PROTOFILERESUME*)mir_alloc(sizeof(pfr));
+			CopyMemory(pfrCopy,&pfr,sizeof(pfr));
+			PostMessage((HWND)GetPropA(hwndDlg,"Miranda.ParentWnd"),M_FILEEXISTSDLGREPLY,(WPARAM)mir_tstrdup(fts->tszCurrentFile),(LPARAM)pfrCopy);
+			DestroyWindow(hwndDlg);
+		}
+		break;
+	}
+
+	case WM_CLOSE:
+		PostMessage(hwndDlg,WM_COMMAND,MAKEWPARAM(IDCANCEL,BN_CLICKED),(LPARAM)GetDlgItem(hwndDlg,IDCANCEL));
+		break;
+
+	case M_PRESHUTDOWN:
+		PostMessage(hwndDlg,WM_CLOSE,0,0);
+		break;
+
+	case WM_DESTROY:
+		UnhookEvent(GetPropA(hwndDlg,"Miranda.Preshutdown")); // GetProp() will return NULL if it couldnt find anything
+		RemovePropA(hwndDlg,"Miranda.Preshutdown");
+		RemovePropA(hwndDlg,"Miranda.ParentWnd");
+		DestroyIcon((HICON)SendDlgItemMessage(hwndDlg,IDC_EXISTINGICON,STM_GETICON,0,0));
+		DestroyIcon((HICON)SendDlgItemMessage(hwndDlg,IDC_NEWICON,STM_GETICON,0,0));
+		FreeProtoFileTransferStatus(fts);
+		mir_free(fts);
+		break;
+	}
+	return FALSE;
+}
+#endif
\ No newline at end of file
Index: MirOTR/fileopts.cpp
===================================================================
--- MirOTR/fileopts.cpp	(revision 0)
+++ MirOTR/fileopts.cpp	(revision 0)
@@ -0,0 +1,246 @@
+/*
+
+Miranda IM: the free IM client for Microsoft* Windows*
+
+Copyright 2000-2009 Miranda ICQ/IM project,
+all portions of this codebase are copyrighted to the people
+listed in contributors.txt.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+*/
+#ifdef _OTR_SEND_FILE
+#include "stdafx.h"
+#define VSCAN_MCAFEE      1
+#define VSCAN_DRSOLOMON   2
+#define VSCAN_NORTON      3
+#define VSCAN_CA          4
+
+struct virusscannerinfo {
+	const TCHAR *szProductName;
+	const TCHAR *szExeRegPath;
+	const TCHAR *szExeRegValue;
+	const TCHAR *szCommandLine;
+};
+
+static const struct virusscannerinfo virusScanners[]={
+	{_T("Network Associates/McAfee VirusScan"),_T("SOFTWARE\\McAfee\\VirusScan"),_T("Scan32EXE"),_T("\"%s\" %%f /nosplash /comp /autoscan /autoexit /noboot")},
+	{_T("Dr Solomon's VirusScan (Network Associates)"),_T("SOFTWARE\\Network Associates\\TVD\\VirusScan\\AVConsol\\General"),_T("szScannerExe"),_T("\"%s\" %%f /uinone /noboot /comp /prompt /autoexit")},
+	{_T("Norton AntiVirus"),_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\Navw32.exe"),NULL,_T("\"%s\" %%f /b- /m- /s+ /noresults")},
+	{_T("Computer Associates/Inoculate IT"),_T("Software\\Antivirus"),_T("ImageFilename"),_T("\"%s\" %%f /display=progress /exit")},
+	{_T("Computer Associates eTrust"),_T("SOFTWARE\\ComputerAssociates\\Anti-Virus\\Resident"),_T("VetPath"),_T("\"%s\" %%f /display=progress /exit")},
+	{_T("Kaspersky Anti-Virus"),_T("SOFTWARE\\KasperskyLab\\Components\\101"),_T("EXEName"),_T("\"%s\" /S /Q %%f")},
+	{_T("Kaspersky Anti-Virus"),_T("SOFTWARE\\KasperskyLab\\SetupFolders"),_T("KAV8"),_T("\"%savp.exe\" SCAN %%f")},
+	{_T("Kaspersky Anti-Virus"),_T("SOFTWARE\\KasperskyLab\\SetupFolders"),_T("KAV9"),_T("\"%savp.exe\" SCAN %%f")},
+	{_T("AntiVir PersonalEdition Classic"),_T("SOFTWARE\\Avira\\AntiVir PersonalEdition Classic"),_T("Path"),_T("\"%savscan.exe\" /GUIMODE=2 /PATH=\"%%f\"")},
+	{_T("ESET NOD32 Antivirus"),_T("SOFTWARE\\ESET\\ESET Security\\CurrentVersion\\Info"),_T("InstallDir"),_T("\"%secls.exe\" /log-all /aind /no-boots /adware /sfx /unsafe /unwanted /heur /adv-heur /action=clean \"%%f\"")},
+};
+
+#define M_UPDATEENABLING   (WM_USER+100)
+#define M_SCANCMDLINESELCHANGE  (WM_USER+101)
+
+#ifndef SHACF_FILESYS_DIRS
+	#define SHACF_FILESYS_DIRS  0x00000020
+#endif
+
+static INT_PTR CALLBACK DlgProcFileOpts(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
+{
+	switch(msg) {
+		case WM_INITDIALOG:
+		{
+			TranslateDialogDefault(hwndDlg);
+
+			if (shAutoComplete)
+				shAutoComplete(GetDlgItem(hwndDlg, IDC_FILEDIR), SHACF_FILESYS_DIRS);
+
+			{
+				TCHAR str[MAX_PATH];
+				GetContactReceivedFilesDir(NULL,str,SIZEOF(str),FALSE);
+				SetDlgItemText(hwndDlg,IDC_FILEDIR,str);
+			}
+
+            CheckDlgButton(hwndDlg, IDC_AUTOACCEPT, DBGetContactSettingByte(NULL,"SRFile","AutoAccept",0) ? BST_CHECKED : BST_UNCHECKED);
+			CheckDlgButton(hwndDlg, IDC_AUTOMIN, DBGetContactSettingByte(NULL,"SRFile","AutoMin",0) ? BST_CHECKED : BST_UNCHECKED);
+			CheckDlgButton(hwndDlg, IDC_AUTOCLOSE, DBGetContactSettingByte(NULL,"SRFile","AutoClose",0) ? BST_CHECKED : BST_UNCHECKED);
+			CheckDlgButton(hwndDlg, IDC_AUTOCLEAR, DBGetContactSettingByte(NULL,"SRFile","AutoClear",1) ? BST_CHECKED : BST_UNCHECKED);
+			switch(DBGetContactSettingByte(NULL,"SRFile","UseScanner",VIRUSSCAN_DISABLE)) {
+				case VIRUSSCAN_AFTERDL: CheckDlgButton(hwndDlg, IDC_SCANAFTERDL, BST_CHECKED); break;
+				case VIRUSSCAN_DURINGDL: CheckDlgButton(hwndDlg, IDC_SCANDURINGDL, BST_CHECKED); break;
+				default: CheckDlgButton(hwndDlg, IDC_NOSCANNER, BST_CHECKED); break;
+			}
+			CheckDlgButton(hwndDlg, IDC_WARNBEFOREOPENING, DBGetContactSettingByte(NULL,"SRFile","WarnBeforeOpening",1) ? BST_CHECKED : BST_UNCHECKED);
+
+			{	TCHAR szScanExe[MAX_PATH];
+				int i,iItem;
+				for( i=0; i < SIZEOF(virusScanners); i++ ) {
+					if(SRFile_GetRegValue(HKEY_LOCAL_MACHINE,virusScanners[i].szExeRegPath,virusScanners[i].szExeRegValue,szScanExe,SIZEOF(szScanExe))) {
+						iItem=SendDlgItemMessage(hwndDlg,IDC_SCANCMDLINE,CB_ADDSTRING,0,(LPARAM)virusScanners[i].szProductName);
+						SendDlgItemMessage(hwndDlg,IDC_SCANCMDLINE,CB_SETITEMDATA,iItem,i);
+					}
+				}
+				if ( SendDlgItemMessageA(hwndDlg,IDC_SCANCMDLINE,CB_GETCOUNT,0,0) == 0 )
+				{
+					iItem = SendDlgItemMessage(hwndDlg,IDC_SCANCMDLINE,CB_ADDSTRING,0,(LPARAM)_T("") );
+					SendDlgItemMessage(hwndDlg,IDC_SCANCMDLINE,CB_SETITEMDATA,iItem, (LPARAM)-1);
+				}
+			}
+
+			DBVARIANT dbv;
+			if(DBGetContactSettingTString(NULL,"SRFile","ScanCmdLine",&dbv)==0) {
+				SetDlgItemText(hwndDlg,IDC_SCANCMDLINE,dbv.ptszVal);
+				DBFreeVariant(&dbv);
+			}
+			else {
+				if(SendDlgItemMessage(hwndDlg,IDC_SCANCMDLINE,CB_GETCOUNT,0,0)) {
+					SendDlgItemMessage(hwndDlg,IDC_SCANCMDLINE,CB_SETCURSEL,0,0);
+					PostMessage(hwndDlg,M_SCANCMDLINESELCHANGE,0,0);
+				}
+			}
+			switch(DBGetContactSettingByte(NULL,"SRFile","IfExists",FILERESUME_ASK)) {
+				case FILERESUME_RESUMEALL: CheckDlgButton(hwndDlg, IDC_RESUME, BST_CHECKED); break;
+				case FILERESUME_OVERWRITEALL: CheckDlgButton(hwndDlg, IDC_OVERWRITE, BST_CHECKED); break;
+				case FILERESUME_RENAMEALL: CheckDlgButton(hwndDlg, IDC_RENAME, BST_CHECKED); break;
+				default: CheckDlgButton(hwndDlg, IDC_ASK, BST_CHECKED); break;
+			}
+			SendMessage(hwndDlg,M_UPDATEENABLING,0,0);
+			return TRUE;
+		}
+		case M_UPDATEENABLING:
+		{	int on=!IsDlgButtonChecked(hwndDlg,IDC_NOSCANNER);
+			EnableWindow(GetDlgItem(hwndDlg,IDC_ST_CMDLINE),on);
+			EnableWindow(GetDlgItem(hwndDlg,IDC_SCANCMDLINE),on);
+			EnableWindow(GetDlgItem(hwndDlg,IDC_SCANCMDLINEBROWSE),on);
+			EnableWindow(GetDlgItem(hwndDlg,IDC_ST_CMDLINEHELP),on);
+			EnableWindow(GetDlgItem(hwndDlg,IDC_AUTOMIN),IsDlgButtonChecked(hwndDlg,IDC_AUTOACCEPT));
+			break;
+		}
+		case M_SCANCMDLINESELCHANGE:
+		{	TCHAR str[512];
+			TCHAR szScanExe[MAX_PATH];
+			int iScanner=SendDlgItemMessage(hwndDlg,IDC_SCANCMDLINE,CB_GETITEMDATA,SendDlgItemMessage(hwndDlg,IDC_SCANCMDLINE,CB_GETCURSEL,0,0),0);
+			if(iScanner >= SIZEOF(virusScanners) || iScanner<0) break;
+			str[0]='\0';
+			if(SRFile_GetRegValue(HKEY_LOCAL_MACHINE,virusScanners[iScanner].szExeRegPath,virusScanners[iScanner].szExeRegValue,szScanExe,SIZEOF(szScanExe)))
+				mir_sntprintf(str, SIZEOF(str), virusScanners[iScanner].szCommandLine,szScanExe);
+			SetDlgItemText(hwndDlg,IDC_SCANCMDLINE,str);
+			break;
+		}
+		case WM_COMMAND:
+			switch(LOWORD(wParam)) {
+				case IDC_FILEDIR:
+					if((HIWORD(wParam)!=EN_CHANGE || (HWND)lParam!=GetFocus())) return 0;
+					break;
+				case IDC_FILEDIRBROWSE:
+				{	TCHAR str[MAX_PATH];
+					GetDlgItemText(hwndDlg,IDC_FILEDIR,str,SIZEOF(str));
+					if(BrowseForFolder(hwndDlg,str))
+						SetDlgItemText(hwndDlg,IDC_FILEDIR,str);
+					break;
+				}
+				case IDC_AUTOACCEPT:
+				case IDC_NOSCANNER:
+				case IDC_SCANAFTERDL:
+				case IDC_SCANDURINGDL:
+					SendMessage(hwndDlg,M_UPDATEENABLING,0,0);
+					break;
+				case IDC_SCANCMDLINE:
+					if(HIWORD(wParam)==CBN_SELCHANGE) PostMessage(hwndDlg,M_SCANCMDLINESELCHANGE,0,0);
+					else if(HIWORD(wParam)!=CBN_EDITCHANGE) return 0;
+					break;
+				case IDC_SCANCMDLINEBROWSE:
+				{	TCHAR str[MAX_PATH+2];
+					OPENFILENAME ofn = {0};
+					TCHAR filter[512], *pfilter;
+
+					GetDlgItemText(hwndDlg, IDC_SCANCMDLINE, str, SIZEOF(str));
+					ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
+					ofn.hwndOwner = hwndDlg;
+					ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_DONTADDTORECENT;
+					_tcscpy(filter,TranslateT("Executable Files"));
+					_tcscat(filter, _T(" (*.exe)"));
+					pfilter = filter + _tcslen(filter) + 1;
+					_tcscpy(pfilter, _T("*.exe"));
+					pfilter = pfilter + _tcslen(pfilter)+1;
+					_tcscpy(pfilter, TranslateT("All Files"));
+					_tcscat(pfilter, _T(" (*)"));
+					pfilter = pfilter + _tcslen(pfilter) + 1;
+					_tcscpy(pfilter, _T("*"));
+					pfilter = pfilter + _tcslen(pfilter) + 1;
+					*pfilter = 0;
+					ofn.lpstrFilter = filter;
+					ofn.lpstrFile = str;
+					ofn.nMaxFile = SIZEOF(str)-2;
+					if(str[0]=='"')	{
+						TCHAR *pszQuote = _tcschr(str + 1, '"');
+						if (pszQuote) *pszQuote = 0;
+						MoveMemory(str, str + 1, _tcslen(str) * sizeof(TCHAR));
+					}
+					else {
+						TCHAR *pszSpace = _tcschr(str, ' ');
+						if (pszSpace) *pszSpace = 0;
+					}
+					ofn.nMaxFileTitle = MAX_PATH;
+					if (!GetOpenFileName(&ofn)) break;
+					if (_tcschr(str, ' ') != NULL) {
+						MoveMemory(str+1, str, SIZEOF(str) - 2 * sizeof(TCHAR));
+						str[0] = '"';
+						_tcscat(str, _T("\""));
+					}
+					SetDlgItemText(hwndDlg, IDC_SCANCMDLINE, str);
+					break;
+				}
+			}
+			SendMessage(GetParent(hwndDlg), PSM_CHANGED, 0, 0);
+			break;
+		case WM_NOTIFY:
+			switch (((LPNMHDR)lParam)->code)
+			{
+				case PSN_APPLY:
+				{	TCHAR str[512];
+					GetDlgItemText(hwndDlg, IDC_FILEDIR, str, SIZEOF(str));
+					RemoveInvalidPathChars(str);
+					DBWriteContactSettingTString(NULL,"SRFile","RecvFilesDirAdv",str);
+					DBWriteContactSettingByte(NULL,"SRFile","AutoAccept",(BYTE)IsDlgButtonChecked(hwndDlg,IDC_AUTOACCEPT));
+					DBWriteContactSettingByte(NULL,"SRFile","AutoMin",(BYTE)IsDlgButtonChecked(hwndDlg,IDC_AUTOMIN));
+					DBWriteContactSettingByte(NULL,"SRFile","AutoClose",(BYTE)IsDlgButtonChecked(hwndDlg,IDC_AUTOCLOSE));
+					DBWriteContactSettingByte(NULL,"SRFile","AutoClear",(BYTE)IsDlgButtonChecked(hwndDlg,IDC_AUTOCLEAR));
+					DBWriteContactSettingByte(NULL,"SRFile","UseScanner",(BYTE)(IsDlgButtonChecked(hwndDlg,IDC_SCANAFTERDL)?VIRUSSCAN_AFTERDL:(IsDlgButtonChecked(hwndDlg,IDC_SCANDURINGDL)?VIRUSSCAN_DURINGDL:VIRUSSCAN_DISABLE)));
+					GetDlgItemText(hwndDlg, IDC_SCANCMDLINE, str, SIZEOF(str));
+					DBWriteContactSettingTString(NULL,"SRFile","ScanCmdLine",str);
+					DBWriteContactSettingByte(NULL,"SRFile","WarnBeforeOpening",(BYTE)IsDlgButtonChecked(hwndDlg,IDC_WARNBEFOREOPENING));
+					DBWriteContactSettingByte(NULL,"SRFile","IfExists",(BYTE)(IsDlgButtonChecked(hwndDlg,IDC_ASK)?FILERESUME_ASK:(IsDlgButtonChecked(hwndDlg,IDC_RESUME)?FILERESUME_RESUMEALL:(IsDlgButtonChecked(hwndDlg,IDC_OVERWRITE)?FILERESUME_OVERWRITEALL:FILERESUME_RENAMEALL))));
+					return TRUE;
+				}
+			}
+			break;
+	}
+	return FALSE;
+}
+
+int FileOptInitialise(WPARAM wParam, LPARAM)
+{
+	OPTIONSDIALOGPAGE odp={0};
+	odp.cbSize = sizeof(odp);
+	odp.position = 900000000;
+	odp.hInstance = hInst;
+	odp.pszTemplate = MAKEINTRESOURCEA(IDD_OPT_FILETRANSFER);
+	odp.pszTitle = LPGEN("Encrypted File Transfers");
+	odp.pszGroup = LPGEN("Events");
+	odp.pfnDlgProc = DlgProcFileOpts;
+	odp.flags = ODPF_BOLDGROUPS;
+	odp.nIDBottomSimpleControl = IDC_VIRUSSCANNERGROUP;
+	CallService( MS_OPT_ADDPAGE, wParam, ( LPARAM )&odp );
+	return 0;
+}
+#endif
Index: MirOTR/filerecvdlg.cpp
===================================================================
--- MirOTR/filerecvdlg.cpp	(revision 0)
+++ MirOTR/filerecvdlg.cpp	(revision 0)
@@ -0,0 +1,452 @@
+/*
+
+Miranda IM: the free IM client for Microsoft* Windows*
+
+Copyright 2000-2009 Miranda ICQ/IM project,
+all portions of this codebase are copyrighted to the people
+listed in contributors.txt.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+*/
+#ifdef _OTR_SEND_FILE
+#include "stdafx.h"
+#define MAX_MRU_DIRS    5
+
+static BOOL CALLBACK ClipSiblingsChildEnumProc(HWND hwnd, LPARAM)
+{
+	SetWindowLongPtr(hwnd,GWL_STYLE,GetWindowLongPtr(hwnd,GWL_STYLE)|WS_CLIPSIBLINGS);
+	return TRUE;
+}
+
+static void GetLowestExistingDirName(const TCHAR *szTestDir,TCHAR *szExistingDir,int cchExistingDir)
+{
+	DWORD dwAttributes;
+	TCHAR *pszLastBackslash;
+
+	lstrcpyn(szExistingDir,szTestDir,cchExistingDir);
+	while((dwAttributes=GetFileAttributes(szExistingDir))!=INVALID_FILE_ATTRIBUTES && !(dwAttributes&FILE_ATTRIBUTE_DIRECTORY)) {
+		pszLastBackslash=_tcsrchr(szExistingDir,'\\');
+		if(pszLastBackslash==NULL) {*szExistingDir='\0'; break;}
+		*pszLastBackslash='\0';
+	}
+	if(szExistingDir[0]=='\0') GetCurrentDirectory(cchExistingDir,szExistingDir);
+}
+
+static const TCHAR InvalidFilenameChars[] = _T("\\/:*?\"<>|"); 
+void RemoveInvalidFilenameChars(TCHAR *tszString)
+{
+	size_t i;
+	if (tszString) {
+		for(i=_tcscspn(tszString,InvalidFilenameChars); tszString[i]; i+=_tcscspn(tszString+i+1,InvalidFilenameChars)+1)
+			if(tszString[i] >= 0) 
+				tszString[i] = _T('_');
+	}
+}
+
+static const TCHAR InvalidPathChars[] = _T("*?\"<>|"); // "\/:" are excluded as they are allowed in file path
+void RemoveInvalidPathChars(TCHAR *tszString)
+{
+	size_t i;
+	if (tszString) {
+		for(i=_tcscspn(tszString,InvalidPathChars); tszString[i]; i+=_tcscspn(tszString+i+1,InvalidPathChars)+1)
+			if(tszString[i] >= 0) 
+				tszString[i] = _T('_');
+	}
+}
+
+static INT CALLBACK BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lp, LPARAM pData)
+{
+	TCHAR szDir[MAX_PATH];
+	switch(uMsg) {
+	case BFFM_INITIALIZED:
+		SendMessage(hwnd, BFFM_SETSELECTION, TRUE, pData);
+		break;
+	case BFFM_SELCHANGED:
+		if (SHGetPathFromIDList((LPITEMIDLIST) lp ,szDir))
+			SendMessage(hwnd,BFFM_SETSTATUSTEXT,0,(LPARAM)szDir);
+		break;
+	}
+	return 0;
+}
+
+int BrowseForFolder(HWND hwnd,TCHAR *szPath)
+{
+	BROWSEINFO bi={0};
+	LPITEMIDLIST pidlResult;
+
+	bi.hwndOwner=hwnd;
+	bi.pszDisplayName=szPath;
+	bi.lpszTitle=TranslateT("Select Folder");
+	bi.ulFlags=BIF_NEWDIALOGSTYLE|BIF_EDITBOX|BIF_RETURNONLYFSDIRS;				// Use this combo instead of BIF_USENEWUI
+	bi.lpfn=BrowseCallbackProc;
+	bi.lParam=(LPARAM)szPath;
+
+	pidlResult=SHBrowseForFolder(&bi);
+	if(pidlResult) {
+		SHGetPathFromIDList(pidlResult,szPath);
+		lstrcat(szPath,_T("\\"));
+		CoTaskMemFree(pidlResult);
+	}
+	return pidlResult != NULL;
+}
+
+static REPLACEVARSARRAY sttVarsToReplace[] =
+{
+	{ ( TCHAR* )"///", ( TCHAR* )"//" },
+	{ ( TCHAR* )"//", ( TCHAR* )"/" },
+	{ ( TCHAR* )"()", ( TCHAR* )"" },
+	{ NULL, NULL }
+};
+
+static void patchDir( TCHAR* str, size_t strSize )
+{
+	REPLACEVARSDATA dat = { 0 };
+	dat.cbSize = sizeof( dat );
+	dat.dwFlags = RVF_TCHAR;
+	dat.variables = sttVarsToReplace;
+
+	TCHAR* result = ( TCHAR* )CallService( MS_UTILS_REPLACEVARS, (WPARAM)str, (LPARAM)&dat );
+	if ( result ) {
+		_tcsncpy( str, result, strSize );
+		mir_free( result );
+	}
+
+	size_t len = lstrlen( str );
+	if ( len+1 < strSize && str[len-1] != '\\' )
+		lstrcpy( str+len, _T("\\") );
+}
+
+void GetContactReceivedFilesDir(HANDLE hContact, TCHAR *szDir, int cchDir, BOOL patchVars)
+{
+	DBVARIANT dbv;
+	TCHAR szTemp[MAX_PATH];
+	szTemp[0] = 0;
+
+	if ( !DBGetContactSettingTString( NULL, "SRFile", "RecvFilesDirAdv", &dbv)) {
+		if ( lstrlen( dbv.ptszVal ) > 0 )
+			lstrcpyn( szTemp, dbv.ptszVal, SIZEOF( szTemp ));
+		DBFreeVariant( &dbv );
+	}
+
+	if ( !szTemp[0] )
+#ifdef _UNICODE
+		mir_sntprintf( szTemp, SIZEOF(szTemp), _T("%%mydocuments%%\\%s\\%%userid%%"), TranslateT("My Received Files"));
+#else
+		mir_sntprintf( szTemp, SIZEOF(szTemp), _T("%%mydocuments%%\\%s\\%%userid%%"), "My Received Files");
+#endif
+
+	if ( hContact ) {
+		REPLACEVARSDATA dat = { 0 };
+		REPLACEVARSARRAY rvaVarsToReplace[4];
+		rvaVarsToReplace[0].lptzKey   = _T("nick");
+		rvaVarsToReplace[0].lptzValue = mir_tstrdup((TCHAR *)CallService(MS_CLIST_GETCONTACTDISPLAYNAME, (WPARAM)hContact, GCDNF_TCHAR));
+		rvaVarsToReplace[1].lptzKey   = _T("userid");
+		rvaVarsToReplace[1].lptzValue = GetContactID(hContact);
+		rvaVarsToReplace[2].lptzKey   = _T("proto");
+		rvaVarsToReplace[2].lptzValue = mir_a2t((char *)CallService(MS_PROTO_GETCONTACTBASEPROTO, (WPARAM)hContact,0));
+		rvaVarsToReplace[3].lptzKey   = NULL;
+		rvaVarsToReplace[3].lptzValue = NULL;
+		for (int i=0; i < (SIZEOF(rvaVarsToReplace)-1);i++)
+			RemoveInvalidFilenameChars(rvaVarsToReplace[i].lptzValue);
+
+		dat.cbSize = sizeof( dat );
+		dat.dwFlags = RVF_TCHAR;
+		dat.variables = rvaVarsToReplace;
+		dat.hContact = hContact;
+		TCHAR* result = ( TCHAR* )CallService( MS_UTILS_REPLACEVARS, (WPARAM)szTemp, (LPARAM)&dat );
+		if ( result ) {
+			_tcsncpy( szTemp, result, SIZEOF(szTemp));
+			mir_free( result );
+			for (int i=0; i < (SIZEOF(rvaVarsToReplace)-1);i++)
+				mir_free(rvaVarsToReplace[i].lptzValue);
+	}	}
+
+	if (patchVars)
+		patchDir( szTemp, SIZEOF(szTemp));
+	RemoveInvalidPathChars(szTemp);
+	lstrcpyn( szDir, szTemp, cchDir );
+}
+
+void GetReceivedFilesDir(TCHAR *szDir, int cchDir)
+{
+	DBVARIANT dbv;
+	TCHAR szTemp[MAX_PATH];
+	szTemp[0] = 0;
+
+	if ( !DBGetContactSettingTString( NULL, "SRFile", "RecvFilesDirAdv", &dbv )) {
+		if ( lstrlen( dbv.ptszVal ) > 0 )
+			lstrcpyn( szTemp, dbv.ptszVal, SIZEOF( szTemp ));
+		DBFreeVariant(&dbv);
+	}
+
+	if ( !szTemp[0] )
+#ifdef _UNICODE
+		mir_sntprintf( szTemp, SIZEOF(szTemp), _T("%%mydocuments%%\\%s"), TranslateT("My Received Files"));
+#else
+		mir_sntprintf( szTemp, SIZEOF(szTemp), _T("%%mydocuments%%\\%s"), "My Received Files");
+#endif
+
+	patchDir( szTemp, SIZEOF(szTemp));
+	RemoveInvalidPathChars(szTemp);
+	lstrcpyn( szDir, szTemp, cchDir );
+}
+
+INT_PTR CALLBACK DlgProcRecvFile(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
+{
+	struct FileDlgData *dat;
+
+	dat=(struct FileDlgData*)GetWindowLongPtr(hwndDlg,GWLP_USERDATA);
+	switch (msg) {
+	case WM_INITDIALOG: {
+		TCHAR *contactName;
+		TCHAR szPath[450];
+		CLISTEVENT* cle = (CLISTEVENT*)lParam;
+
+		TranslateDialogDefault(hwndDlg);
+
+		dat=(struct FileDlgData*)mir_calloc(sizeof(struct FileDlgData));
+		SetWindowLongPtr(hwndDlg,GWLP_USERDATA,(LONG_PTR)dat);
+		dat->hContact = cle->hContact;
+		dat->hDbEvent = cle->hDbEvent;
+		dat->hPreshutdownEvent = HookEventMessage(ME_SYSTEM_PRESHUTDOWN,hwndDlg,M_PRESHUTDOWN);
+		dat->dwTicks = GetTickCount();
+
+		EnumChildWindows(hwndDlg,ClipSiblingsChildEnumProc,0);
+
+		Window_SetIcon_IcoLib(hwndDlg, "core_main_3"); // event file
+		Button_SetIcon_IcoLib(hwndDlg, IDC_ADD, "core_main_8", LPGEN("Add Contact Permanently to List")); // add contact
+		Button_SetIcon_IcoLib(hwndDlg, IDC_DETAILS, "core_main_9", LPGEN("View User's Details")); // user details
+		Button_SetIcon_IcoLib(hwndDlg, IDC_HISTORY, "core_main_10", LPGEN("View User's History")); // other history
+		Button_SetIcon_IcoLib(hwndDlg, IDC_USERMENU, "core_main_11", LPGEN("User Menu")); // other downarrow
+
+		contactName = pcli->pfnGetContactDisplayName( dat->hContact, 0 );
+		SetDlgItemText(hwndDlg,IDC_FROM,contactName);
+		GetContactReceivedFilesDir(dat->hContact,szPath,SIZEOF(szPath),TRUE);
+		SetDlgItemText(hwndDlg,IDC_FILEDIR,szPath);
+		{
+			int i;
+			char idstr[32];
+			DBVARIANT dbv;
+
+			if (shAutoComplete)
+				shAutoComplete(GetWindow(GetDlgItem(hwndDlg,IDC_FILEDIR),GW_CHILD),1);
+
+			for(i=0;i<MAX_MRU_DIRS;i++) {
+				mir_snprintf(idstr, SIZEOF(idstr), "MruDir%d",i);
+				if(DBGetContactSettingTString(NULL,"SRFile",idstr,&dbv)) break;
+				SendDlgItemMessage(hwndDlg,IDC_FILEDIR,CB_ADDSTRING,0,(LPARAM)dbv.ptszVal);
+				DBFreeVariant(&dbv);
+			}
+		}
+
+		CallService(MS_DB_EVENT_MARKREAD,(WPARAM)dat->hContact,(LPARAM)dat->hDbEvent);
+		{
+			DBEVENTINFO dbei={0};
+			DBTIMETOSTRINGT dbtts;
+			TCHAR datetimestr[64];
+			char buf[540];
+
+			dbei.cbSize=sizeof(dbei);
+			dbei.cbBlob=CallService(MS_DB_EVENT_GETBLOBSIZE,(WPARAM)dat->hDbEvent,0);
+			dbei.pBlob=(PBYTE)mir_alloc(dbei.cbBlob);
+			CallService(MS_DB_EVENT_GET,(WPARAM)dat->hDbEvent,(LPARAM)&dbei);
+
+			dat->fs = cle->lParam ? (HANDLE)cle->lParam : (HANDLE)*(PDWORD)dbei.pBlob;
+
+			lstrcpynA(buf, (char*)dbei.pBlob+4, min(dbei.cbBlob+1,SIZEOF(buf)));
+			TCHAR* ptszFileName = DbGetEventStringT( &dbei, buf );
+			SetDlgItemText(hwndDlg,IDC_FILENAMES,ptszFileName);
+			mir_free(ptszFileName);
+			lstrcpynA(buf, (char*)dbei.pBlob+4+strlen((char*)dbei.pBlob+4)+1, min((int)(dbei.cbBlob-4-strlen((char*)dbei.pBlob+4)),SIZEOF(buf)));
+			TCHAR* ptszDescription = DbGetEventStringT( &dbei, buf );
+			SetDlgItemText(hwndDlg,IDC_MSG,ptszDescription);
+			mir_free(ptszDescription);
+			mir_free(dbei.pBlob);
+
+			dbtts.szFormat = _T("t d");
+			dbtts.szDest = datetimestr;
+			dbtts.cbDest = SIZEOF(datetimestr);
+			CallService(MS_DB_TIME_TIMESTAMPTOSTRINGT, dbei.timestamp, ( LPARAM )&dbtts);
+			SetDlgItemText(hwndDlg, IDC_DATE, datetimestr);
+		}
+		{
+			char* szProto = (char*)CallService(MS_PROTO_GETCONTACTBASEPROTO, (WPARAM)dat->hContact, 0);
+			if (szProto) {
+				CONTACTINFO ci;
+				int hasName = 0;
+				char buf[128];
+				ZeroMemory(&ci,sizeof(ci));
+
+				ci.cbSize = sizeof(ci);
+				ci.hContact = dat->hContact;
+				ci.szProto = szProto;
+				ci.dwFlag = CNF_UNIQUEID;
+				if (!CallService(MS_CONTACT_GETCONTACTINFO,0,(LPARAM)&ci)) {
+					switch(ci.type) {
+					case CNFT_ASCIIZ:
+						hasName = 1;
+						mir_snprintf(buf, SIZEOF(buf), "%s", ci.pszVal);
+						mir_free(ci.pszVal);
+						break;
+					case CNFT_DWORD:
+						hasName = 1;
+						mir_snprintf(buf, SIZEOF(buf),"%u",ci.dVal);
+						break;
+				}	}
+				if (hasName)
+					SetDlgItemTextA(hwndDlg, IDC_NAME, buf );
+				else
+					SetDlgItemText(hwndDlg, IDC_NAME, contactName);
+		}	}
+
+		if(DBGetContactSettingByte(dat->hContact,"CList","NotOnList",0)) {
+			RECT rcBtn1,rcBtn2,rcDateCtrl;
+			GetWindowRect(GetDlgItem(hwndDlg,IDC_ADD),&rcBtn1);
+			GetWindowRect(GetDlgItem(hwndDlg,IDC_USERMENU),&rcBtn2);
+			GetWindowRect(GetDlgItem(hwndDlg,IDC_DATE),&rcDateCtrl);
+			SetWindowPos(GetDlgItem(hwndDlg,IDC_DATE),0,0,0,rcDateCtrl.right-rcDateCtrl.left-(rcBtn2.left-rcBtn1.left),rcDateCtrl.bottom-rcDateCtrl.top,SWP_NOZORDER|SWP_NOMOVE);
+		}
+		else if(DBGetContactSettingByte(NULL,"SRFile","AutoAccept",0)) {
+			//don't check auto-min here to fix BUG#647620
+			PostMessage(hwndDlg,WM_COMMAND,MAKEWPARAM(IDOK,BN_CLICKED),(LPARAM)GetDlgItem(hwndDlg,IDOK));
+		}
+		if(!DBGetContactSettingByte(dat->hContact,"CList","NotOnList",0))
+			ShowWindow(GetDlgItem(hwndDlg, IDC_ADD),SW_HIDE);
+		return TRUE;
+	}
+
+	case WM_MEASUREITEM:
+		return CallService(MS_CLIST_MENUMEASUREITEM,wParam,lParam);
+
+	case WM_DRAWITEM:
+		{	LPDRAWITEMSTRUCT dis=(LPDRAWITEMSTRUCT)lParam;
+			if(dis->hwndItem==GetDlgItem(hwndDlg, IDC_PROTOCOL)) {
+				char *szProto;
+
+				szProto=(char*)CallService(MS_PROTO_GETCONTACTBASEPROTO,(WPARAM)dat->hContact,0);
+				if (szProto) {
+					HICON hIcon;
+
+					hIcon=(HICON)CallProtoService(szProto,PS_LOADICON,PLI_PROTOCOL|PLIF_SMALL,0);
+					if (hIcon) {
+						DrawIconEx(dis->hDC,dis->rcItem.left,dis->rcItem.top,hIcon,GetSystemMetrics(SM_CXSMICON),GetSystemMetrics(SM_CYSMICON),0,NULL,DI_NORMAL);
+						DestroyIcon(hIcon);
+		}	}	}	}
+		return CallService(MS_CLIST_MENUDRAWITEM,wParam,lParam);
+
+	case WM_COMMAND:
+		if ( CallService(MS_CLIST_MENUPROCESSCOMMAND, MAKEWPARAM(LOWORD(wParam),MPCF_CONTACTMENU), (LPARAM)dat->hContact ))
+			break;
+
+		switch ( LOWORD( wParam )) {
+		case IDC_FILEDIRBROWSE:
+			{
+				TCHAR szDirName[MAX_PATH],szExistingDirName[MAX_PATH];
+
+				GetDlgItemText(hwndDlg,IDC_FILEDIR,szDirName,SIZEOF(szDirName));
+				GetLowestExistingDirName(szDirName,szExistingDirName,SIZEOF(szExistingDirName));
+				if(BrowseForFolder(hwndDlg,szExistingDirName))
+					SetDlgItemText(hwndDlg,IDC_FILEDIR,szExistingDirName);
+			}
+            break;
+
+		case IDOK:
+			{	//most recently used directories
+				TCHAR szRecvDir[MAX_PATH],szDefaultRecvDir[MAX_PATH];
+				GetDlgItemText(hwndDlg,IDC_FILEDIR,szRecvDir,SIZEOF(szRecvDir));
+				RemoveInvalidPathChars(szRecvDir);
+				GetContactReceivedFilesDir(NULL,szDefaultRecvDir,SIZEOF(szDefaultRecvDir),TRUE);
+				if(_tcsnicmp(szRecvDir,szDefaultRecvDir,lstrlen(szDefaultRecvDir))) {
+					char idstr[32];
+					int i;
+					DBVARIANT dbv;
+					for(i=MAX_MRU_DIRS-2;i>=0;i--) {
+						mir_snprintf(idstr, SIZEOF(idstr), "MruDir%d",i);
+						if(DBGetContactSettingTString(NULL,"SRFile",idstr,&dbv)) continue;
+						mir_snprintf(idstr, SIZEOF(idstr), "MruDir%d",i+1);
+						DBWriteContactSettingTString(NULL,"SRFile",idstr,dbv.ptszVal);
+						DBFreeVariant(&dbv);
+					}
+					DBWriteContactSettingTString(NULL,"SRFile",idstr,szRecvDir);
+				}
+			}
+			EnableWindow(GetDlgItem(hwndDlg,IDC_FILENAMES),FALSE);
+			EnableWindow(GetDlgItem(hwndDlg,IDC_MSG),FALSE);
+			EnableWindow(GetDlgItem(hwndDlg,IDC_FILEDIR),FALSE);
+			EnableWindow(GetDlgItem(hwndDlg,IDC_FILEDIRBROWSE),FALSE);
+
+			GetDlgItemText(hwndDlg,IDC_FILEDIR,dat->szSavePath,SIZEOF(dat->szSavePath));
+			GetDlgItemText(hwndDlg,IDC_FILE,dat->szFilenames,SIZEOF(dat->szFilenames));
+			GetDlgItemText(hwndDlg,IDC_MSG,dat->szMsg,SIZEOF(dat->szMsg));
+			dat->hwndTransfer = FtMgr_AddTransfer(dat);
+			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, 0);
+			//check for auto-minimize here to fix BUG#647620
+			if(DBGetContactSettingByte(NULL,"SRFile","AutoAccept",0) && DBGetContactSettingByte(NULL,"SRFile","AutoMin",0)) {
+				ShowWindow(hwndDlg,SW_HIDE);
+				ShowWindow(hwndDlg,SW_SHOWMINNOACTIVE);
+			}
+			DestroyWindow(hwndDlg);
+            break;
+
+		case IDCANCEL:
+			if (dat->fs) CallContactService(dat->hContact,PSS_FILEDENYT,(WPARAM)dat->fs,(LPARAM)TranslateT("Cancelled"));
+			dat->fs=NULL; /* the protocol will free the handle */
+			DestroyWindow(hwndDlg);
+            break;
+
+		case IDC_ADD:
+			{	ADDCONTACTSTRUCT acs={0};
+
+				acs.handle=dat->hContact;
+				acs.handleType=HANDLE_CONTACT;
+				acs.szProto="";
+				CallService(MS_ADDCONTACT_SHOW,(WPARAM)hwndDlg,(LPARAM)&acs);
+				if(!DBGetContactSettingByte(dat->hContact,"CList","NotOnList",0))
+					ShowWindow(GetDlgItem(hwndDlg,IDC_ADD), SW_HIDE);
+			}
+            break;
+
+		case IDC_USERMENU:
+			{	RECT rc;
+				HMENU hMenu=(HMENU)CallService(MS_CLIST_MENUBUILDCONTACT,(WPARAM)dat->hContact,0);
+				GetWindowRect((HWND)lParam,&rc);
+				TrackPopupMenu(hMenu,0,rc.left,rc.bottom,0,hwndDlg,NULL);
+				DestroyMenu(hMenu);
+			}
+			break;
+
+		case IDC_DETAILS:
+			CallService(MS_USERINFO_SHOWDIALOG,(WPARAM)dat->hContact,0);
+            break;
+
+		case IDC_HISTORY:
+			CallService(MS_HISTORY_SHOWCONTACTHISTORY,(WPARAM)dat->hContact,0);
+            break;
+		}
+		break;
+
+	case WM_DESTROY:
+		Window_FreeIcon_IcoLib(hwndDlg);
+		Button_FreeIcon_IcoLib(hwndDlg,IDC_ADD);
+		Button_FreeIcon_IcoLib(hwndDlg,IDC_DETAILS);
+		Button_FreeIcon_IcoLib(hwndDlg,IDC_HISTORY);
+		Button_FreeIcon_IcoLib(hwndDlg,IDC_USERMENU);
+
+		if ( dat ) FreeFileDlgData( dat );
+        break;
+	}
+	return FALSE;
+}
+#endif
Index: MirOTR/filesenddlg.cpp
===================================================================
--- MirOTR/filesenddlg.cpp	(revision 0)
+++ MirOTR/filesenddlg.cpp	(revision 0)
@@ -0,0 +1,361 @@
+/*
+
+Miranda IM: the free IM client for Microsoft* Windows*
+
+Copyright 2000-2009 Miranda ICQ/IM project,
+all portions of this codebase are copyrighted to the people
+listed in contributors.txt.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+*/
+#ifdef _OTR_SEND_FILE
+#include "stdafx.h"
+static void SetFileListAndSizeControls(HWND hwndDlg,struct FileDlgData *dat)
+{
+	int fileCount=0,dirCount=0,totalSize=0,i;
+	struct _stat statbuf;
+	TCHAR str[64];
+
+	for ( i=0; dat->files[i]; i++ ) {
+		if ( _tstat( dat->files[i], &statbuf ) == 0 ) {
+			if ( statbuf.st_mode & _S_IFDIR)
+				dirCount++;
+			else
+				fileCount++;
+			totalSize += statbuf.st_size;
+	}	}
+
+	GetSensiblyFormattedSize(totalSize,str,SIZEOF(str),0,1,NULL);
+	SetDlgItemText(hwndDlg,IDC_TOTALSIZE,str);
+	if(i>1) {
+		TCHAR szFormat[32];
+		if(fileCount && dirCount) {
+			mir_sntprintf(szFormat,SIZEOF(szFormat),_T("%s, %s"),TranslateTS(fileCount==1?_T("%d file"):_T("%d files")),TranslateTS(dirCount==1?_T("%d directory"):_T("%d directories")));
+			mir_sntprintf(str,SIZEOF(str),szFormat,fileCount,dirCount);
+		}
+		else if(fileCount) {
+			lstrcpy(szFormat,TranslateT("%d files"));
+			mir_sntprintf(str,SIZEOF(str),szFormat,fileCount);
+		}
+		else {
+			lstrcpy(szFormat,TranslateT("%d directories"));
+			mir_sntprintf(str,SIZEOF(str),szFormat,dirCount);
+		}
+		SetDlgItemText(hwndDlg,IDC_FILE,str);
+	}
+	else SetDlgItemText(hwndDlg,IDC_FILE,dat->files[0]);
+
+	EnableWindow(GetDlgItem(hwndDlg, IDOK), fileCount || dirCount);
+}
+
+static void FilenameToFileList(HWND hwndDlg, struct FileDlgData* dat, const TCHAR* buf)
+{
+	DWORD dwFileAttributes;
+
+	// Make sure that the file matrix is empty (the user may select files several times)
+	FreeFilesMatrix(&dat->files);
+
+	// Get the file attributes of selection
+	dwFileAttributes = GetFileAttributes( buf );
+	if (dwFileAttributes == INVALID_FILE_ATTRIBUTES)
+		return;
+
+	// Check if the selection is a directory or a file
+	if ( GetFileAttributes( buf ) & FILE_ATTRIBUTE_DIRECTORY ) {
+		const TCHAR* pBuf;
+		int nNumberOfFiles = 0;
+		int nTemp;
+		int fileOffset;
+
+		// :NOTE: The first string in the buffer is the directory, followed by a
+		// NULL separated list of all files
+
+		// fileOffset is the offset to the first file.
+		fileOffset = lstrlen(buf) + 1;
+
+		// Count number of files
+		pBuf = buf + fileOffset;
+		while ( *pBuf ) {
+			pBuf += lstrlen(pBuf) + 1;
+			nNumberOfFiles++;
+		}
+
+		// Allocate memory for a pointer array
+		if (( dat->files = ( TCHAR* *)mir_alloc((nNumberOfFiles + 1) * sizeof(TCHAR*))) == NULL )
+			return;
+
+		// Fill the array
+		pBuf = buf + fileOffset;
+		nTemp = 0;
+		while(*pBuf)
+		{
+			// Allocate space for path+filename
+			int cbFileNameLen = lstrlen( pBuf );
+			dat->files[nTemp] = ( TCHAR* )mir_alloc( sizeof(TCHAR)*(fileOffset + cbFileNameLen + 1));
+
+			// Add path to filename and copy into array
+			#if defined( _UNICODE )
+				CopyMemory(dat->files[nTemp], buf, (fileOffset-1)*sizeof( TCHAR ));
+				dat->files[nTemp][fileOffset-1] = '\\';
+				_tcscpy(dat->files[nTemp] + fileOffset - (buf[fileOffset-2]=='\\'?1:0), pBuf);
+			#else
+				CopyMemory(dat->files[nTemp], buf, fileOffset-1 );
+				dat->files[nTemp][fileOffset-1] = '\\';
+				strcpy(dat->files[nTemp] + fileOffset - (buf[fileOffset-2]=='\\'?1:0), pBuf);
+			#endif
+			// Move pointers to next file...
+			pBuf += cbFileNameLen + 1;
+			nTemp++;
+		}
+		// Terminate array
+		dat->files[nNumberOfFiles] = NULL;
+	}
+	// ...the selection is a single file
+	else
+	{
+		if (( dat->files = ( TCHAR **)mir_alloc(2 * sizeof( TCHAR*))) == NULL ) // Leaks when aborted
+			return;
+
+		dat->files[0] = mir_tstrdup(buf);
+		dat->files[1] = NULL;
+	}
+
+	// Update dialog text with new file selection
+	SetFileListAndSizeControls(hwndDlg, dat);
+}
+
+#define M_FILECHOOSEDONE  (WM_USER+100)
+void __cdecl ChooseFilesThread(void* param)
+{
+	HWND hwndDlg = ( HWND )param;
+	TCHAR filter[128], *pfilter;
+	TCHAR* buf = ( TCHAR* )mir_alloc( sizeof(TCHAR)*32767 );
+	if ( buf == NULL )
+		PostMessage( hwndDlg, M_FILECHOOSEDONE, 0, ( LPARAM )( TCHAR* )NULL );
+	else {
+		OPENFILENAME ofn = {0};
+		ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
+		ofn.hwndOwner   = hwndDlg;
+		lstrcpy( filter, TranslateT( "All Files" ));
+		lstrcat( filter, _T(" (*)" ));
+		pfilter = filter + lstrlen( filter )+1;
+		lstrcpy( pfilter, _T( "*" ));
+		pfilter = filter + lstrlen( filter )+1;
+		pfilter[ 0 ] = '\0';
+		ofn.lpstrFilter = filter;
+		ofn.lpstrFile = buf; *buf = 0;
+		ofn.nMaxFile = 32767;
+		ofn.Flags = OFN_NOCHANGEDIR | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT | OFN_EXPLORER | OFN_HIDEREADONLY | OFN_DONTADDTORECENT;
+		if ( GetOpenFileName( &ofn ))
+			PostMessage( hwndDlg, M_FILECHOOSEDONE, 0, ( LPARAM )buf );
+		else {
+			mir_free( buf );
+			PostMessage( hwndDlg, M_FILECHOOSEDONE, 0, ( LPARAM )( TCHAR* )NULL );
+}	}	}
+
+static BOOL CALLBACK ClipSiblingsChildEnumProc(HWND hwnd,LPARAM)
+{
+	SetWindowLongPtr(hwnd,GWL_STYLE,GetWindowLongPtr(hwnd,GWL_STYLE)|WS_CLIPSIBLINGS);
+	return TRUE;
+}
+
+static WNDPROC OldSendEditProc;
+static LRESULT CALLBACK SendEditSubclassProc(HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam)
+{
+	switch(msg) {
+		case WM_CHAR:
+			if(wParam=='\n' && GetKeyState(VK_CONTROL)&0x8000) {
+				PostMessage(GetParent(hwnd),WM_COMMAND,IDOK,0);
+				return 0;
+			}
+			break;
+		case WM_SYSCHAR:
+			if((wParam=='s' || wParam=='S') && GetKeyState(VK_MENU)&0x8000) {
+				PostMessage(GetParent(hwnd),WM_COMMAND,IDOK,0);
+				return 0;
+			}
+			break;
+	}
+	return CallWindowProc(OldSendEditProc,hwnd,msg,wParam,lParam);
+}
+
+INT_PTR CALLBACK DlgProcSendFile(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
+{
+	struct FileDlgData *dat;
+
+	dat=(struct FileDlgData*)GetWindowLongPtr(hwndDlg,GWLP_USERDATA);
+	switch (msg) {
+	case WM_INITDIALOG:
+	{
+		struct FileSendData *fsd=(struct FileSendData*)lParam;
+
+		dat=(struct FileDlgData*)mir_calloc(sizeof(struct FileDlgData));
+		SetWindowLongPtr(hwndDlg,GWLP_USERDATA,(LONG_PTR)dat);
+		dat->hContact=fsd->hContact;
+		dat->send=1;
+		dat->hPreshutdownEvent=HookEventMessage(ME_SYSTEM_PRESHUTDOWN,hwndDlg,M_PRESHUTDOWN);
+		dat->fs=NULL;
+		dat->dwTicks=GetTickCount();
+
+		TranslateDialogDefault(hwndDlg);
+		EnumChildWindows(hwndDlg,ClipSiblingsChildEnumProc,0);
+		OldSendEditProc=(WNDPROC)SetWindowLongPtr(GetDlgItem(hwndDlg,IDC_MSG),GWLP_WNDPROC,(LONG_PTR)SendEditSubclassProc);
+
+		Window_SetIcon_IcoLib(hwndDlg, "core_main_3"); // event file
+		Button_SetIcon_IcoLib(hwndDlg, IDC_DETAILS, "core_main_9", LPGEN("View User's Details")); // other userdetails
+		Button_SetIcon_IcoLib(hwndDlg, IDC_HISTORY, "core_main_10", LPGEN("View User's History")); // other history
+		Button_SetIcon_IcoLib(hwndDlg, IDC_USERMENU, "core_main_11", LPGEN("User Menu")); // downarrow
+
+        EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE);
+
+		if(fsd->ppFiles!=NULL && fsd->ppFiles[0]!=NULL) {
+			int totalCount,i;
+			for(totalCount=0;fsd->ppFiles[totalCount];totalCount++);
+			dat->files = ( TCHAR** )mir_alloc( sizeof(TCHAR*)*(totalCount+1)); // Leaks
+			for(i=0;i<totalCount;i++)
+				dat->files[i] = mir_tstrdup( fsd->ppFiles[i] );
+			dat->files[totalCount]=NULL;
+			SetFileListAndSizeControls(hwndDlg,dat);
+		}
+		{
+			char *szProto;
+			TCHAR* contactName = pcli->pfnGetContactDisplayName( dat->hContact, 0 );
+			SetDlgItemText(hwndDlg,IDC_TO,contactName);
+
+			szProto=(char*)CallService(MS_PROTO_GETCONTACTBASEPROTO,(WPARAM)dat->hContact,0);
+			if (szProto) {
+				CONTACTINFO ci;
+				int hasName = 0;
+				char buf[128];
+				ZeroMemory(&ci,sizeof(ci));
+
+				ci.cbSize = sizeof(ci);
+				ci.hContact = dat->hContact;
+				ci.szProto = szProto;
+				ci.dwFlag = CNF_UNIQUEID;
+				if (!CallService(MS_CONTACT_GETCONTACTINFO,0,(LPARAM)&ci)) {
+					switch(ci.type) {
+						case CNFT_ASCIIZ:
+							hasName = 1;
+							mir_snprintf(buf, SIZEOF(buf), "%s", ci.pszVal);
+							mir_free(ci.pszVal);
+							break;
+						case CNFT_DWORD:
+							hasName = 1;
+							mir_snprintf(buf, SIZEOF(buf),"%u",ci.dVal);
+							break;
+				}	}
+
+				if ( hasName )
+					SetDlgItemTextA(hwndDlg,IDC_NAME,buf);
+				else
+					SetDlgItemText(hwndDlg,IDC_NAME,contactName);
+		}	}
+
+		if ( fsd->ppFiles == NULL ) {
+       		EnableWindow(hwndDlg, FALSE);
+			dat->closeIfFileChooseCancelled=1;
+			PostMessage(hwndDlg,WM_COMMAND,MAKEWPARAM(IDC_CHOOSE,BN_CLICKED),(LPARAM)GetDlgItem(hwndDlg,IDC_CHOOSE));
+		}
+		return TRUE;
+	}
+
+	case WM_MEASUREITEM:
+		return CallService(MS_CLIST_MENUMEASUREITEM,wParam,lParam);
+
+	case WM_DRAWITEM:
+		{
+			LPDRAWITEMSTRUCT dis=(LPDRAWITEMSTRUCT)lParam;
+			if(dis->hwndItem==GetDlgItem(hwndDlg, IDC_PROTOCOL)) {
+				char *szProto;
+
+				szProto=(char*)CallService(MS_PROTO_GETCONTACTBASEPROTO,(WPARAM)dat->hContact,0);
+				if (szProto) {
+					HICON hIcon = (HICON)CallProtoService(szProto,PS_LOADICON,PLI_PROTOCOL|PLIF_SMALL,0);
+					if (hIcon) {
+						DrawIconEx(dis->hDC,dis->rcItem.left,dis->rcItem.top,hIcon,GetSystemMetrics(SM_CXSMICON),GetSystemMetrics(SM_CYSMICON),0,NULL,DI_NORMAL);
+						DestroyIcon(hIcon);
+		}	}	}	}
+		return CallService(MS_CLIST_MENUDRAWITEM,wParam,lParam);
+		
+	case M_FILECHOOSEDONE:
+		if( lParam != 0 ) {
+			FilenameToFileList( hwndDlg, dat, ( TCHAR* )lParam );
+			mir_free(( TCHAR* )lParam );
+			dat->closeIfFileChooseCancelled = 0;
+		}
+		else if(dat->closeIfFileChooseCancelled) DestroyWindow(hwndDlg);
+		EnableWindow(hwndDlg,TRUE);
+		break;
+
+	case WM_COMMAND:
+		if(CallService(MS_CLIST_MENUPROCESSCOMMAND,MAKEWPARAM(LOWORD(wParam),MPCF_CONTACTMENU),(LPARAM)dat->hContact))
+			break;
+		switch (LOWORD(wParam))
+		{
+			case IDC_CHOOSE:
+				EnableWindow(hwndDlg,FALSE);
+				//GetOpenFileName() creates its own message queue which prevents any incoming events being processed
+				forkthread(ChooseFilesThread,0,hwndDlg);
+				break;
+			case IDOK:
+				EnableWindow(GetDlgItem(hwndDlg,IDC_FILENAME),FALSE);
+				EnableWindow(GetDlgItem(hwndDlg,IDC_MSG),FALSE);
+				EnableWindow(GetDlgItem(hwndDlg,IDC_CHOOSE),FALSE);
+
+				GetDlgItemText(hwndDlg,IDC_FILEDIR,dat->szSavePath,SIZEOF(dat->szSavePath));
+				GetDlgItemText(hwndDlg,IDC_FILE,dat->szFilenames,SIZEOF(dat->szFilenames));
+				GetDlgItemText(hwndDlg,IDC_MSG,dat->szMsg,SIZEOF(dat->szMsg));
+				dat->hwndTransfer = FtMgr_AddTransfer(dat);
+				SetWindowLongPtr( hwndDlg, GWLP_USERDATA, 0);
+				DestroyWindow(hwndDlg);
+				return TRUE;
+
+			case IDCANCEL:
+				DestroyWindow(hwndDlg);
+				return TRUE;
+
+			case IDC_USERMENU:
+			{	RECT rc;
+				HMENU hMenu=(HMENU)CallService(MS_CLIST_MENUBUILDCONTACT,(WPARAM)dat->hContact,0);
+				GetWindowRect((HWND)lParam,&rc);
+				TrackPopupMenu(hMenu,0,rc.left,rc.bottom,0,hwndDlg,NULL);
+				DestroyMenu(hMenu);
+				break;
+			}
+			case IDC_DETAILS:
+				CallService(MS_USERINFO_SHOWDIALOG,(WPARAM)dat->hContact,0);
+				return TRUE;
+			case IDC_HISTORY:
+				CallService(MS_HISTORY_SHOWCONTACTHISTORY,(WPARAM)dat->hContact,0);
+				return TRUE;
+		}
+		break;
+
+	case WM_DESTROY:
+		Window_FreeIcon_IcoLib(hwndDlg);
+		Button_FreeIcon_IcoLib(hwndDlg,IDC_DETAILS);
+		Button_FreeIcon_IcoLib(hwndDlg,IDC_HISTORY);
+		Button_FreeIcon_IcoLib(hwndDlg,IDC_USERMENU);
+
+		if ( dat )
+			FreeFileDlgData( dat );
+		
+		SetWindowLongPtr(GetDlgItem(hwndDlg,IDC_MSG),GWLP_WNDPROC,(LONG_PTR)OldSendEditProc);
+		return TRUE;
+	}
+	return FALSE;
+}
+#endif
Index: MirOTR/filexferdlg.cpp
===================================================================
--- MirOTR/filexferdlg.cpp	(revision 0)
+++ MirOTR/filexferdlg.cpp	(revision 0)
@@ -0,0 +1,910 @@
+/*
+
+Miranda IM: the free IM client for Microsoft* Windows*
+
+Copyright 2000-2010 Miranda ICQ/IM project,
+all portions of this codebase are copyrighted to the people
+listed in contributors.txt.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+*/
+#ifdef _OTR_SEND_FILE
+#include "stdafx.h"
+#include <iostream>
+#include <fstream>
+#define HM_RECVEVENT    (WM_USER+10)
+
+static int CheckVirusScanned(HWND hwnd,struct FileDlgData *dat,int i)
+{
+	if(dat->send) return 1;
+	if(dat->fileVirusScanned == NULL) return 0;
+	if(dat->fileVirusScanned[i]) return 1;
+	if(DBGetContactSettingByte(NULL,"SRFile","WarnBeforeOpening",1)==0) return 1;
+	return IDYES==MessageBox(hwnd,TranslateT("This file has not yet been scanned for viruses. Are you certain you want to open it?"),TranslateT("File Received"),MB_YESNO|MB_DEFBUTTON2);
+}
+
+#define M_VIRUSSCANDONE  (WM_USER+100)
+struct virusscanthreadstartinfo {
+	TCHAR *szFile;
+	int returnCode;
+	HWND hwndReply;
+};
+
+TCHAR* PFTS_StringToTchar( int flags, const PROTOCHAR* s )
+{
+#ifdef  _UNICODE
+	if ( flags & PFTS_UTF )
+		return Utf8DecodeUcs2(( char* )s );
+	else if ( flags & PFTS_UNICODE )
+		return mir_tstrdup( s );
+	else
+		return mir_a2t(( char* )s );
+#else
+	if ( flags & PFTS_UTF ) {
+		char *szAnsi = mir_strdup(( char* )s );
+		return Utf8Decode(szAnsi, NULL);
+	}
+	else
+		return mir_strdup( s );
+#endif
+}
+
+int PFTS_CompareWithTchar( PROTOFILETRANSFERSTATUS* ft, const PROTOCHAR* s, TCHAR* r )
+{
+#ifdef _UNICODE
+	if ( ft->flags & PFTS_UTF ) {
+		TCHAR* ts = Utf8DecodeUcs2(( char* )s );
+		int res = _tcscmp( ts, r );
+		mir_free( ts );
+		return res;
+	}
+	else if ( ft->flags & PFTS_UNICODE )
+		return _tcscmp( s, r );
+	else {
+	  TCHAR* ts = mir_a2t(( char* )s );
+	  int res = _tcscmp( ts, r );
+	  mir_free( ts );
+	  return res;
+	}
+#else
+	if ( ft->flags & PFTS_UTF ) {
+		char *ts = NEWSTR_ALLOCA(( char* )s );
+		return _tcscmp( Utf8Decode(( char* )ts, NULL), r );
+	}
+	else
+		return _tcscmp( s, r );
+#endif
+}
+
+static void SetOpenFileButtonStyle(HWND hwndButton,int enabled)
+{
+	EnableWindow(hwndButton,enabled);
+}
+
+void FillSendData( FileDlgData* dat, DBEVENTINFO& dbei )
+{
+	dbei.cbSize = sizeof(dbei);
+	dbei.szModule = (char*)CallService(MS_PROTO_GETCONTACTBASEPROTO,(WPARAM)dat->hContact,0);
+	dbei.eventType = EVENTTYPE_FILE;
+	dbei.flags = DBEF_SENT;
+	dbei.timestamp = time(NULL);
+	#if defined( _UNICODE )
+		char *szFileNames = Utf8EncodeT(dat->szFilenames), *szMsg = Utf8EncodeT(dat->szMsg);
+		dbei.flags |= DBEF_UTF;
+	#else
+		char *szFileNames = dat->szFilenames, *szMsg = dat->szMsg;
+	#endif
+
+	dbei.cbBlob = sizeof(DWORD) + lstrlenA(szFileNames)+lstrlenA(szMsg)+2;
+	dbei.pBlob=(PBYTE)mir_alloc(dbei.cbBlob);
+	*(PDWORD)dbei.pBlob=0;
+	lstrcpyA((char*)dbei.pBlob+sizeof(DWORD),szFileNames);
+	lstrcpyA((char*)dbei.pBlob+sizeof(DWORD)+lstrlenA(szFileNames)+1,szMsg);
+
+	#if defined( _UNICODE )
+		mir_free( szFileNames ), mir_free( szMsg );
+	#endif
+}
+
+static void __cdecl RunVirusScannerThread(struct virusscanthreadstartinfo *info)
+{
+	PROCESS_INFORMATION pi;
+	STARTUPINFO si={0};
+	DBVARIANT dbv;
+	TCHAR szCmdLine[768];
+
+	if (!DBGetContactSettingTString(NULL,"SRFile", "ScanCmdLine", &dbv)) 
+	{
+		if(dbv.ptszVal[0]) 
+		{
+			TCHAR *pszReplace;
+			si.cb=sizeof(si);
+			pszReplace = _tcsstr(dbv.ptszVal, _T("%f"));
+			if (pszReplace) 
+			{
+				if ( info->szFile[_tcslen(info->szFile) - 1] == '\\')
+					info->szFile[_tcslen(info->szFile) - 1] = '\0';
+				*pszReplace = 0;
+				mir_sntprintf(szCmdLine, SIZEOF(szCmdLine), _T("%s\"%s\"%s"), dbv.ptszVal, info->szFile, pszReplace+2);
+			}
+			else lstrcpyn(szCmdLine, dbv.ptszVal, SIZEOF(szCmdLine));
+			if(CreateProcess(NULL,szCmdLine,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi)) {
+				if(WaitForSingleObject(pi.hProcess,3600*1000)==WAIT_OBJECT_0)
+					PostMessage(info->hwndReply,M_VIRUSSCANDONE,info->returnCode,0);
+				CloseHandle(pi.hProcess);
+				CloseHandle(pi.hThread);
+			}
+		}
+		DBFreeVariant(&dbv);
+	}
+	mir_free(info->szFile);
+	mir_free(info);
+}
+
+static void SetFilenameControls(HWND hwndDlg, struct FileDlgData *dat, PROTOFILETRANSFERSTATUS *fts)
+{
+	TCHAR msg[MAX_PATH];
+	TCHAR *fnbuf = NULL, *fn = NULL;
+	SHFILEINFO shfi = {0};
+
+	if ( fts->tszCurrentFile ) {
+		fnbuf = mir_tstrdup( fts->tszCurrentFile );
+		if (( fn = _tcsrchr( fnbuf, '\\' )) == NULL )
+			fn = fnbuf;
+		else fn++;
+	}
+
+	if (dat->hIcon) DestroyIcon(dat->hIcon); dat->hIcon = NULL;
+
+	if (fn && (fts->totalFiles > 1)) {
+		mir_sntprintf(msg, SIZEOF(msg), _T("%s: %s (%d %s %d)"),
+			pcli->pfnGetContactDisplayName( fts->hContact, 0 ),
+			fn, fts->currentFileNumber+1, TranslateT("of"), fts->totalFiles);
+
+		SHGetFileInfo(fn, FILE_ATTRIBUTE_DIRECTORY, &shfi, sizeof(shfi), SHGFI_USEFILEATTRIBUTES|SHGFI_ICON|SHGFI_SMALLICON);
+		dat->hIcon = shfi.hIcon;
+	} 
+	else if (fn) {
+		mir_sntprintf(msg, SIZEOF(msg), _T("%s: %s"), pcli->pfnGetContactDisplayName( fts->hContact, 0 ), fn);
+
+		SHGetFileInfo(fn, FILE_ATTRIBUTE_NORMAL, &shfi, sizeof(shfi), SHGFI_USEFILEATTRIBUTES|SHGFI_ICON|SHGFI_SMALLICON);
+		dat->hIcon = shfi.hIcon;
+	} 
+	else {
+		lstrcpyn(msg, pcli->pfnGetContactDisplayName( fts->hContact, 0 ), SIZEOF(msg));
+		HICON hIcon = LoadIcon("core_main_11", 0); // down arrow icon
+		dat->hIcon = CopyIcon(hIcon);
+		ReleaseIcon(hIcon, 0);
+	}
+
+	mir_free( fnbuf );
+	
+	SendDlgItemMessage(hwndDlg, IDC_FILEICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)dat->hIcon);
+	SetDlgItemText(hwndDlg, IDC_CONTACTNAME, msg);
+}
+
+enum { FTS_TEXT, FTS_PROGRESS, FTS_OPEN };
+static void SetFtStatus(HWND hwndDlg, TCHAR *text, int mode)
+{
+	SetDlgItemText(hwndDlg,IDC_STATUS,TranslateTS(text));
+	SetDlgItemText(hwndDlg,IDC_TRANSFERCOMPLETED,TranslateTS(text));
+
+	ShowWindow(GetDlgItem(hwndDlg,IDC_STATUS), (mode == FTS_TEXT)?SW_SHOW:SW_HIDE);
+	ShowWindow(GetDlgItem(hwndDlg,IDC_ALLFILESPROGRESS), (mode == FTS_PROGRESS)?SW_SHOW:SW_HIDE);
+	ShowWindow(GetDlgItem(hwndDlg,IDC_TRANSFERCOMPLETED), (mode == FTS_OPEN)?SW_SHOW:SW_HIDE);
+	ShowWindow(GetDlgItem(hwndDlg,IDC_FILEICON), (mode == FTS_OPEN)?SW_SHOW:SW_HIDE);
+}
+
+static void HideProgressControls(HWND hwndDlg)
+{
+	RECT rc;
+	char buf[64];
+
+	GetWindowRect(GetDlgItem(hwndDlg, IDC_ALLPRECENTS), &rc);
+	MapWindowPoints(NULL, hwndDlg, (LPPOINT)&rc, 2);
+	SetWindowPos(hwndDlg, NULL, 0, 0, 100, rc.bottom+3, SWP_NOMOVE|SWP_NOZORDER);
+	ShowWindow(GetDlgItem(hwndDlg, IDC_ALLTRANSFERRED), SW_HIDE);
+	ShowWindow(GetDlgItem(hwndDlg, IDC_ALLSPEED), SW_HIDE);
+
+	_strtime(buf);
+	SetDlgItemTextA(hwndDlg, IDC_ALLPRECENTS, buf);
+
+	PostMessage(GetParent(hwndDlg), WM_FT_RESIZE, 0, (LPARAM)hwndDlg);
+}
+
+static int FileTransferDlgResizer(HWND, LPARAM, UTILRESIZECONTROL *urc)
+{
+	switch(urc->wId) {
+		case IDC_CONTACTNAME:
+		case IDC_STATUS:
+		case IDC_ALLFILESPROGRESS:
+		case IDC_TRANSFERCOMPLETED:
+			return RD_ANCHORX_WIDTH|RD_ANCHORY_TOP;
+		case IDC_FRAME:
+			return RD_ANCHORX_WIDTH|RD_ANCHORY_BOTTOM;
+		case IDC_ALLPRECENTS:
+		case IDCANCEL:
+		case IDC_OPENFILE:
+		case IDC_OPENFOLDER:
+			return RD_ANCHORX_RIGHT|RD_ANCHORY_TOP;
+
+		case IDC_ALLTRANSFERRED:
+			urc->rcItem.right = urc->rcItem.left + (urc->rcItem.right - urc->rcItem.left - urc->dlgOriginalSize.cx + urc->dlgNewSize.cx) / 3;
+			return RD_ANCHORX_CUSTOM|RD_ANCHORY_CUSTOM;
+
+		case IDC_ALLSPEED:
+			urc->rcItem.right = urc->rcItem.right - urc->dlgOriginalSize.cx + urc->dlgNewSize.cx;
+			urc->rcItem.left = urc->rcItem.left + (urc->rcItem.right - urc->rcItem.left) / 3;
+			return RD_ANCHORX_CUSTOM|RD_ANCHORY_CUSTOM;
+	}
+	return RD_ANCHORX_LEFT|RD_ANCHORY_TOP;
+}
+
+void WriteDecryptedFile(FileDlgData* dat, int idx) {
+	using namespace std;
+
+	char *cfile = mir_u2a(dat->files[idx]);
+	ifstream file (cfile, ios::in|ios::binary|ios::ate);
+	if (file.is_open())
+	{
+		int size = file.tellg();
+		char* memblock = new char [size];
+		file.seekg (0, ios::beg);
+		file.read (memblock, size);
+		file.close();
+
+		char *newmessage = 0;
+		char *proto = (char *)CallService(MS_PROTO_GETCONTACTBASEPROTO, (WPARAM)dat->hContact, 0);
+		char *username = contact_get_id(dat->hContact);
+
+		OtrlTLV *tlvs = NULL;
+		OtrlTLV *tlv = NULL;
+
+		lib_cs_lock();
+		otrl_message_receiving(otr_user_state, &ops, (void*)dat->hContact,
+			proto, proto, username, memblock,
+			&newmessage, &tlvs, add_appdata, (void*)dat->hContact);
+		lib_cs_unlock();
+
+
+		tlv = otrl_tlv_find(tlvs, OTRL_TLV_DISCONNECTED);
+		if (tlv) {
+			/* Notify the user that the other side disconnected. */
+			TCHAR buff[256];
+			mir_sntprintf(buff, 256, TranslateT(LANG_SESSION_TERMINATED_BY_OTR), contact_get_nameT(dat->hContact));
+			ShowMessage((HANDLE)dat->hContact, buff);
+		}
+
+		lib_cs_lock();
+		ConnContext *context = otrl_context_find_miranda(otr_user_state, dat->hContact);
+		lib_cs_unlock();
+		/* Keep track of our current progress in the Socialist Millionaires'
+		* Protocol. */
+		if (context && ( (context->smstate->sm_prog_state == OTRL_SMP_PROG_CHEATED) ||
+			otrl_tlv_find(tlvs, OTRL_TLV_SMP1Q) ||
+			otrl_tlv_find(tlvs, OTRL_TLV_SMP1) ||
+			otrl_tlv_find(tlvs, OTRL_TLV_SMP2) || 
+			otrl_tlv_find(tlvs, OTRL_TLV_SMP3) ||
+			otrl_tlv_find(tlvs, OTRL_TLV_SMP4) )
+			)
+		{
+			otr_abort_smp(context); // we do not support it (yet), notify partner to shorten wait time
+		}
+
+		otrl_tlv_free(tlvs);
+
+		mir_free(username);
+
+		if (newmessage) {
+			remove(cfile); // remove old encrypted file
+			int len = strrchr(cfile, '.') - cfile;
+			cfile[len] = '\0';
+			// TODO: for later: option to specify whether file transfer is to be encypted, and fix it so it doesn't require a message prior
+			// to sending file to initialize session..
+
+			// TODO: also, file name can be encrypted too, remove OTR? prefix as ? is an illegal character, then readd it for decryption
+			// well b64 has / which are also invalid characters for a file name
+			ofstream decfile(cfile, ios::out|ios::binary);
+			decfile.write(newmessage, context->datalen - 1);
+			decfile.close();
+			otrl_message_free(newmessage);
+		}
+
+		delete[] memblock;
+	}
+	mir_free(cfile);
+}
+
+INT_PTR CALLBACK DlgProcFileTransfer(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
+{
+	FileDlgData *dat = (FileDlgData*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
+
+	switch (msg)
+	{
+		case WM_INITDIALOG:
+			TranslateDialogDefault(hwndDlg);
+			dat = (FileDlgData*)lParam;
+			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)dat);
+			dat->hNotifyEvent=HookEventMessage(ME_PROTO_ACK,hwndDlg,HM_RECVEVENT);
+			dat->transferStatus.currentFileNumber = -1;
+
+			if(dat->send) {
+				dat->fs=(HANDLE)CallContactService(dat->hContact,PSS_FILET,(WPARAM)dat->szMsg,(LPARAM)dat->files);
+				SetFtStatus(hwndDlg, LPGENT("Request sent, waiting for acceptance..."), FTS_TEXT);
+				SetOpenFileButtonStyle(GetDlgItem(hwndDlg,IDC_OPENFILE),1);
+				dat->waitingForAcceptance=1;
+				// hide "open" button since it may cause potential access violations...
+				ShowWindow(GetDlgItem(hwndDlg, IDC_OPENFILE), SW_HIDE);
+				ShowWindow(GetDlgItem(hwndDlg, IDC_OPENFOLDER), SW_HIDE);
+			}
+			else {	//recv
+				CreateDirectoryTreeT(dat->szSavePath);
+
+				dat->fs=(HANDLE)CallContactService(dat->hContact,PSS_FILEALLOWT,(WPARAM)dat->fs,(LPARAM)dat->szSavePath);
+				dat->transferStatus.tszWorkingDir = mir_tstrdup(dat->szSavePath);
+				if(DBGetContactSettingByte(dat->hContact,"CList","NotOnList",0)) dat->resumeBehaviour=FILERESUME_ASK;
+				else dat->resumeBehaviour=DBGetContactSettingByte(NULL,"SRFile","IfExists",FILERESUME_ASK);
+				SetFtStatus(hwndDlg, LPGENT("Waiting for connection..."), FTS_TEXT);
+			}
+
+			{
+				// check we actually got an fs handle back from the protocol
+				if (!dat->fs) {
+					SetFtStatus(hwndDlg, LPGENT("Unable to initiate transfer."), FTS_TEXT);
+					dat->waitingForAcceptance=0;
+				}
+			}
+			{	LOGFONT lf;
+				HFONT hFont;
+				hFont=(HFONT)SendDlgItemMessage(hwndDlg,IDC_CONTACTNAME,WM_GETFONT,0,0);
+				GetObject(hFont,sizeof(lf),&lf);
+				lf.lfWeight=FW_BOLD;
+				hFont=CreateFontIndirect(&lf);
+				SendDlgItemMessage(hwndDlg,IDC_CONTACTNAME,WM_SETFONT,(WPARAM)hFont,0);
+			}
+
+			{	SHFILEINFO shfi = {0};
+				SHGetFileInfo(_T(""), FILE_ATTRIBUTE_DIRECTORY, &shfi, sizeof(shfi), SHGFI_USEFILEATTRIBUTES|SHGFI_ICON|SHGFI_SMALLICON);
+				dat->hIconFolder = shfi.hIcon;
+			}
+
+			dat->hIcon = NULL;
+
+			SendDlgItemMessage(hwndDlg, IDC_CONTACT, BM_SETIMAGE, IMAGE_ICON,
+				(LPARAM)LoadSkinnedProtoIcon((char *)CallService(MS_PROTO_GETCONTACTBASEPROTO, (WPARAM)dat->hContact, 0), ID_STATUS_ONLINE));
+			SendDlgItemMessage(hwndDlg, IDC_CONTACT, BUTTONADDTOOLTIP, (WPARAM)LPGEN("Contact menu"), 0);
+			SendDlgItemMessage(hwndDlg, IDC_CONTACT, BUTTONSETASFLATBTN, 0, 0);
+
+			Button_SetIcon_IcoLib(hwndDlg, IDC_OPENFILE, "core_main_11", LPGEN("Open..."));// downarrow
+			SendDlgItemMessage(hwndDlg, IDC_OPENFILE, BUTTONSETASPUSHBTN, 0, 0);
+
+			SendDlgItemMessage(hwndDlg, IDC_OPENFOLDER, BM_SETIMAGE, IMAGE_ICON, (LPARAM)dat->hIconFolder);
+			SendDlgItemMessage(hwndDlg, IDC_OPENFOLDER, BUTTONADDTOOLTIP, (WPARAM)LPGEN("Open folder"), 0);
+			SendDlgItemMessage(hwndDlg, IDC_OPENFOLDER, BUTTONSETASFLATBTN, 0, 0);
+		
+			Button_SetIcon_IcoLib(hwndDlg, IDCANCEL, "core_main_15", LPGEN("Cancel")); // other delete
+
+			SetDlgItemText(hwndDlg, IDC_CONTACTNAME, pcli->pfnGetContactDisplayName( dat->hContact, 0 ));
+
+			if(!dat->waitingForAcceptance) SetTimer(hwndDlg,1,1000,NULL);
+
+			return TRUE;
+		case WM_TIMER:
+			MoveMemory(dat->bytesRecvedHistory+1,dat->bytesRecvedHistory,sizeof(dat->bytesRecvedHistory)-sizeof(dat->bytesRecvedHistory[0]));
+			dat->bytesRecvedHistory[0]=dat->transferStatus.totalProgress;
+			if ( dat->bytesRecvedHistorySize < SIZEOF(dat->bytesRecvedHistory))
+				dat->bytesRecvedHistorySize++;
+
+			{	TCHAR szSpeed[32], szTime[32], szDisplay[96];
+				SYSTEMTIME st;
+				ULARGE_INTEGER li;
+				FILETIME ft;
+
+				GetSensiblyFormattedSize((dat->bytesRecvedHistory[0]-dat->bytesRecvedHistory[dat->bytesRecvedHistorySize-1])/dat->bytesRecvedHistorySize,szSpeed,SIZEOF(szSpeed),0,1,NULL);
+				if(dat->bytesRecvedHistory[0]==dat->bytesRecvedHistory[dat->bytesRecvedHistorySize-1])
+					lstrcpy(szTime,_T("??:??:??"));
+				else {
+					li.QuadPart=BIGI(10000000)*(dat->transferStatus.currentFileSize-dat->transferStatus.currentFileProgress)*dat->bytesRecvedHistorySize/(dat->bytesRecvedHistory[0]-dat->bytesRecvedHistory[dat->bytesRecvedHistorySize-1]);
+					ft.dwHighDateTime=li.HighPart; ft.dwLowDateTime=li.LowPart;
+					FileTimeToSystemTime(&ft,&st);
+					GetTimeFormat(LOCALE_USER_DEFAULT,TIME_FORCE24HOURFORMAT|TIME_NOTIMEMARKER,&st,NULL,szTime,SIZEOF(szTime));
+				}
+				if(dat->bytesRecvedHistory[0]!=dat->bytesRecvedHistory[dat->bytesRecvedHistorySize-1]) {
+					li.QuadPart=BIGI(10000000)*(dat->transferStatus.totalBytes-dat->transferStatus.totalProgress)*dat->bytesRecvedHistorySize/(dat->bytesRecvedHistory[0]-dat->bytesRecvedHistory[dat->bytesRecvedHistorySize-1]);
+					ft.dwHighDateTime=li.HighPart; ft.dwLowDateTime=li.LowPart;
+					FileTimeToSystemTime(&ft,&st);
+					GetTimeFormat(LOCALE_USER_DEFAULT,TIME_FORCE24HOURFORMAT|TIME_NOTIMEMARKER,&st,NULL,szTime,SIZEOF(szTime));
+				}
+
+				mir_sntprintf(szDisplay,SIZEOF(szDisplay),_T("%s/%s  (%s %s)"),szSpeed,TranslateT("sec"),szTime,TranslateT("remaining"));
+				SetDlgItemText(hwndDlg,IDC_ALLSPEED,szDisplay);
+			}
+			break;
+
+		case WM_MEASUREITEM:
+			return CallService(MS_CLIST_MENUMEASUREITEM,wParam,lParam);
+
+		case WM_DRAWITEM:
+			return CallService(MS_CLIST_MENUDRAWITEM,wParam,lParam);
+
+		case WM_FT_CLEANUP:
+			if (!dat->fs)
+			{
+				PostMessage(GetParent(hwndDlg), WM_FT_REMOVE, 0, (LPARAM)hwndDlg);
+				DestroyWindow(hwndDlg);
+			}
+
+		case WM_COMMAND:
+			if ( CallService(MS_CLIST_MENUPROCESSCOMMAND, MAKEWPARAM(LOWORD(wParam),MPCF_CONTACTMENU), (LPARAM)dat->hContact ))
+				break;
+
+			switch (LOWORD(wParam)) 
+			{
+				case IDOK:
+				case IDCANCEL:
+					PostMessage(GetParent(hwndDlg), WM_FT_REMOVE, 0, (LPARAM)hwndDlg);
+					DestroyWindow(hwndDlg);
+					break;
+
+				case IDC_CONTACT:
+					{	RECT rc;
+						HMENU hMenu=(HMENU)CallService(MS_CLIST_MENUBUILDCONTACT,(WPARAM)dat->hContact,0);
+						GetWindowRect((HWND)lParam,&rc);
+						TrackPopupMenu(hMenu,0,rc.left,rc.bottom,0,hwndDlg,NULL);
+						DestroyMenu(hMenu);
+						break;
+					}
+
+				case IDC_TRANSFERCOMPLETED:
+					if (dat->transferStatus.currentFileNumber <= 1 && CheckVirusScanned(hwndDlg, dat, 0))
+					{
+						ShellExecute(NULL, NULL, dat->files[0], NULL, NULL, SW_SHOW);
+						break;
+					}
+
+				case IDC_OPENFOLDER:
+					if ( dat ) 
+					{
+						TCHAR* path = dat->transferStatus.tszWorkingDir;
+						if (!path || !path[0])
+						{
+							path = NEWTSTR_ALLOCA(dat->transferStatus.tszCurrentFile);
+							TCHAR* p = _tcsrchr(path, '\\'); if (p) *p = 0;
+						}
+
+						if (path) ShellExecute(NULL, _T("open"), path, NULL, NULL, SW_SHOW);
+					}
+					break;
+
+				case IDC_OPENFILE:
+				{
+					TCHAR **files;
+					HMENU hMenu;
+					RECT rc;
+					int ret;
+
+					if (dat->send)
+						if (dat->files == NULL)
+							files = dat->transferStatus.ptszFiles;
+						else
+							files = dat->files;
+					else
+						files=dat->files;
+
+					hMenu = CreatePopupMenu();
+					AppendMenu(hMenu, MF_STRING, 1, TranslateT("Open folder"));
+					AppendMenu(hMenu, MF_SEPARATOR, 0, 0);
+
+					if (files && *files)
+					{
+						int i, limit;
+						TCHAR *pszFilename,*pszNewFileName;
+
+						if (dat->send)
+							limit = dat->transferStatus.totalFiles;
+						else
+							limit = dat->transferStatus.currentFileNumber;
+
+						// Loop over all transfered files and add them to the menu
+						for (i = 0; i < limit; i++) {
+							pszFilename = _tcsrchr(files[i], '\\');
+							if (pszFilename == NULL)
+								pszFilename = files[i];
+							else
+								pszFilename++;
+							{
+								if (pszFilename) {
+									size_t cbFileNameLen = _tcslen(pszFilename);
+
+									pszNewFileName = (TCHAR*)mir_alloc( cbFileNameLen*2*sizeof( TCHAR ));
+									TCHAR *p = pszNewFileName;
+									for (size_t pszlen=0; pszlen < cbFileNameLen; pszlen++) {
+										*p++ = pszFilename[pszlen];
+										if (pszFilename[pszlen]=='&')
+											*p++ = '&';
+									}
+									*p = '\0';
+									AppendMenu(hMenu, MF_STRING, i+10, pszNewFileName);
+									mir_free(pszNewFileName);
+								}
+							}
+						}
+					}
+
+					GetWindowRect((HWND)lParam, &rc);
+					CheckDlgButton(hwndDlg, IDC_OPENFILE, BST_CHECKED);
+					ret = TrackPopupMenu(hMenu, TPM_RETURNCMD|TPM_RIGHTALIGN, rc.right, rc.bottom, 0, hwndDlg, NULL);
+					CheckDlgButton(hwndDlg, IDC_OPENFILE, BST_UNCHECKED);
+					DestroyMenu(hMenu);
+
+					if (ret == 1)
+					{
+						TCHAR* path = dat->transferStatus.tszWorkingDir;
+						if (!path || !path[0])
+						{
+							path = NEWTSTR_ALLOCA(dat->transferStatus.tszCurrentFile);
+							TCHAR* p = _tcsrchr(path, '\\'); if (p) *p = 0;
+						}
+
+						if (path) ShellExecute(NULL, _T("open"), path, NULL, NULL, SW_SHOW);
+					}
+					else if (ret && CheckVirusScanned(hwndDlg, dat, ret))
+						ShellExecute(NULL, NULL, files[ret-10], NULL, NULL, SW_SHOW);
+
+					break;
+				}
+			}
+			break;
+		case M_FILEEXISTSDLGREPLY:
+		{	PROTOFILERESUME *pfr=(PROTOFILERESUME*)lParam;
+			TCHAR *szOriginalFilename=(TCHAR*)wParam;
+			char *szProto=(char*)CallService(MS_PROTO_GETCONTACTBASEPROTO,(WPARAM)dat->hContact,0);
+
+			EnableWindow(hwndDlg,TRUE);
+			switch(pfr->action) {
+				case FILERESUME_CANCEL:
+					if (dat->fs) CallContactService(dat->hContact,PSS_FILECANCEL,(WPARAM)dat->fs,0);
+					dat->fs=NULL;
+					mir_free(szOriginalFilename);
+					if(pfr->szFilename) mir_free((char*)pfr->szFilename);
+					mir_free(pfr);
+					return 0;
+				case FILERESUME_RESUMEALL:
+				case FILERESUME_OVERWRITEALL:
+					dat->resumeBehaviour=pfr->action;
+					pfr->action&=~FILERESUMEF_ALL;
+					break;
+				case FILERESUME_RENAMEALL:
+					pfr->action=FILERESUME_RENAME;
+					{	TCHAR *pszExtension,*pszFilename;
+						int i;
+						if((pszFilename = _tcsrchr(szOriginalFilename,'\\'))==NULL) pszFilename=szOriginalFilename;
+						if((pszExtension = _tcsrchr(pszFilename+1,'.'))==NULL) pszExtension=pszFilename+lstrlen(pszFilename);
+						if(pfr->szFilename) mir_free((TCHAR*)pfr->szFilename);
+						pfr->szFilename = (TCHAR*)mir_alloc(sizeof(TCHAR)*((pszExtension-szOriginalFilename)+21+lstrlen(pszExtension)));
+						for(i=1;;i++) {
+							_stprintf((TCHAR*)pfr->szFilename,_T("%.*s (%u)%s"),pszExtension-szOriginalFilename,szOriginalFilename,i,pszExtension);
+							if(_taccess(pfr->szFilename,0)!=0)
+								break;
+						}
+					}
+					break;
+			}
+			mir_free(szOriginalFilename);
+			CallProtoService(szProto,PS_FILERESUMET,(WPARAM)dat->fs,(LPARAM)pfr);
+			if(pfr->szFilename) mir_free((char*)pfr->szFilename);
+			mir_free(pfr);
+			break;
+		}
+		case HM_RECVEVENT:
+		{	ACKDATA *ack=(ACKDATA*)lParam;
+			if (ack->hProcess!=dat->fs) break; // icq abuses this sometimes
+			if(ack->hContact!=dat->hContact) break;
+			if(ack->type!=ACKTYPE_FILE) break;
+
+			if(dat->waitingForAcceptance) {
+				SetTimer(hwndDlg,1,1000,NULL);
+				dat->waitingForAcceptance=0;
+			}
+			switch(ack->result) {
+				case ACKRESULT_SENTREQUEST: SetFtStatus(hwndDlg, LPGENT("Decision sent"), FTS_TEXT); break;
+				case ACKRESULT_CONNECTING: SetFtStatus(hwndDlg, LPGENT("Connecting..."), FTS_TEXT); break;
+				case ACKRESULT_CONNECTPROXY: SetFtStatus(hwndDlg, LPGENT("Connecting to proxy..."), FTS_TEXT); break;
+				case ACKRESULT_CONNECTED: SetFtStatus(hwndDlg, LPGENT("Connected"), FTS_TEXT); break;
+				case ACKRESULT_LISTENING: SetFtStatus(hwndDlg, LPGENT("Waiting for connection..."), FTS_TEXT); break;
+				case ACKRESULT_INITIALISING: SetFtStatus(hwndDlg, LPGENT("Initialising..."), FTS_TEXT); break;
+				case ACKRESULT_NEXTFILE:
+					SetFtStatus(hwndDlg, LPGENT("Moving to next file..."), FTS_TEXT);
+					SetDlgItemTextA(hwndDlg,IDC_FILENAME,"");
+					if(dat->transferStatus.currentFileNumber==1 && dat->transferStatus.totalFiles>1 && !dat->send)
+						SetOpenFileButtonStyle(GetDlgItem(hwndDlg,IDC_OPENFILE),1);
+					if(dat->transferStatus.currentFileNumber!=-1 && dat->files && !dat->send && DBGetContactSettingByte(NULL,"SRFile","UseScanner",VIRUSSCAN_DISABLE)==VIRUSSCAN_DURINGDL) {
+						if(GetFileAttributes(dat->files[dat->transferStatus.currentFileNumber])&FILE_ATTRIBUTE_DIRECTORY)
+							PostMessage(hwndDlg,M_VIRUSSCANDONE,dat->transferStatus.currentFileNumber,0);
+						else {
+							virusscanthreadstartinfo *vstsi;
+							vstsi=(struct virusscanthreadstartinfo*)mir_alloc(sizeof(struct virusscanthreadstartinfo));
+							vstsi->hwndReply = hwndDlg;
+							vstsi->szFile = mir_tstrdup(dat->files[dat->transferStatus.currentFileNumber]);
+							vstsi->returnCode = dat->transferStatus.currentFileNumber;
+							forkthread((void (*)(void*))RunVirusScannerThread,0,vstsi);
+						}
+					}
+					break;
+				case ACKRESULT_FILERESUME:
+				{
+					// encrypted transfer code
+					int curFile = dat->transferStatus.currentFileNumber;
+					UpdateProtoFileTransferStatus(&dat->transferStatus, (PROTOFILETRANSFERSTATUS*)ack->lParam);
+					if (curFile > -1 && curFile != dat->transferStatus.currentFileNumber) {
+						if (!dat->send) {
+							WriteDecryptedFile(dat, curFile);
+						}
+					}
+
+					PROTOFILETRANSFERSTATUS *fts = &dat->transferStatus; 
+
+					SetFilenameControls( hwndDlg, dat, fts );
+					int res = _taccess( fts->tszCurrentFile, 0 );
+					if ( res )
+						break;
+
+					SetFtStatus(hwndDlg, LPGENT("File already exists"), FTS_TEXT);
+					if(dat->resumeBehaviour==FILERESUME_ASK) {
+						TDlgProcFileExistsParam param = { hwndDlg, fts };
+						ShowWindow(hwndDlg,SW_SHOWNORMAL);
+						CreateDialogParam(hInst,MAKEINTRESOURCE(IDD_FILEEXISTS),hwndDlg,DlgProcFileExists,(LPARAM)&param);
+						EnableWindow(hwndDlg,FALSE);
+					}
+					else {
+						PROTOFILERESUME *pfr;
+						pfr=(PROTOFILERESUME*)mir_alloc(sizeof(PROTOFILERESUME));
+						pfr->action = dat->resumeBehaviour;
+						pfr->szFilename = NULL;
+						PostMessage(hwndDlg,M_FILEEXISTSDLGREPLY,(WPARAM)mir_tstrdup(fts->tszCurrentFile),(LPARAM)pfr);
+					}
+					SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,1);
+					return TRUE;
+				}
+				case ACKRESULT_DATA:
+				{
+					PROTOFILETRANSFERSTATUS *fts=(PROTOFILETRANSFERSTATUS*)ack->lParam;
+					TCHAR str[64], str2[64], szSizeDone[32], szSizeTotal[32];//,*contactName;
+					int units;
+
+					if ( dat->fileVirusScanned==NULL )
+						dat->fileVirusScanned=(int*)mir_calloc(sizeof(int) * fts->totalFiles);
+
+					// This needs to be here - otherwise we get holes in the files array
+					if (!dat->send) 
+					{
+						if (dat->files == NULL)
+							dat->files = (TCHAR**)mir_calloc((fts->totalFiles + 1) * sizeof(TCHAR*));
+						if (fts->currentFileNumber < fts->totalFiles && dat->files[fts->currentFileNumber] == NULL) 
+						{
+							if (fts->cbSize == sizeof(PROTOFILETRANSFERSTATUS_V1))
+							{
+								PROTOFILETRANSFERSTATUS_V1 *fts1 = (PROTOFILETRANSFERSTATUS_V1*)fts;
+								dat->files[fts->currentFileNumber] = PFTS_StringToTchar(0, (PROTOCHAR*)fts1->currentFile);
+							}
+							else
+								dat->files[fts->currentFileNumber] = PFTS_StringToTchar(fts->flags, fts->tszCurrentFile);
+						}
+					}
+
+					// HACK: for 0.3.3, limit updates to around 1.1 ack per second
+					if (fts->totalProgress != fts->totalBytes && GetTickCount() < (dat->dwTicks + 650)) break; // the last update was less than a second ago!
+					dat->dwTicks = GetTickCount();
+
+					// Update local transfer status with data from protocol
+					UpdateProtoFileTransferStatus(&dat->transferStatus, fts);
+					fts = &dat->transferStatus;
+
+					bool firstTime = false;
+					if ((GetWindowLong(GetDlgItem(hwndDlg, IDC_ALLFILESPROGRESS), GWL_STYLE) & WS_VISIBLE) == 0)
+					{
+						SetFtStatus(hwndDlg, ( fts->flags & PFTS_SENDING ) ? LPGENT("Sending...") : LPGENT("Receiving..."), FTS_PROGRESS);
+						SetFilenameControls(hwndDlg, dat, fts);
+						firstTime = true;
+					}
+
+					const unsigned long lastPos = SendDlgItemMessage(hwndDlg, IDC_ALLFILESPROGRESS, PBM_GETPOS, 0, 0);
+					const unsigned long nextPos = fts->totalBytes ? (BIGI(100) * fts->totalProgress / fts->totalBytes) : 0;
+					if (lastPos != nextPos || firstTime)
+					{
+						SendDlgItemMessage(hwndDlg, IDC_ALLFILESPROGRESS, PBM_SETPOS, nextPos, 0);
+						mir_sntprintf(str, SIZEOF(str), _T("%u%%"), nextPos);
+						SetDlgItemText(hwndDlg, IDC_ALLPRECENTS, str);
+					}
+
+					GetSensiblyFormattedSize(fts->totalBytes, szSizeTotal, SIZEOF(szSizeTotal), 0, 1, &units);
+					GetSensiblyFormattedSize(fts->totalProgress, szSizeDone, SIZEOF(szSizeDone), units, 0, NULL);
+					mir_sntprintf(str, SIZEOF(str), _T("%s/%s"), szSizeDone, szSizeTotal);
+					str2[0] = 0;
+					GetDlgItemText(hwndDlg, IDC_ALLTRANSFERRED, str2, SIZEOF(str2));
+					if (_tcscmp(str, str2)) SetDlgItemText(hwndDlg, IDC_ALLTRANSFERRED, str);
+					break;
+				}
+
+				case ACKRESULT_SUCCESS:
+				case ACKRESULT_FAILED:
+				case ACKRESULT_DENIED:
+				{
+
+					HideProgressControls(hwndDlg);
+					KillTimer(hwndDlg,1);
+					if (!dat->send)
+						SetOpenFileButtonStyle(GetDlgItem(hwndDlg,IDC_OPENFILE),1);
+					SetDlgItemText(hwndDlg,IDCANCEL,TranslateT("Close"));
+					if (dat->hNotifyEvent) 
+						UnhookEvent(dat->hNotifyEvent);
+					dat->hNotifyEvent=NULL;
+					
+					if (ack->result == ACKRESULT_DENIED)
+					{
+						dat->fs=NULL; // protocol will free structure
+						SkinPlaySound("FileDenied");
+						SetFtStatus(hwndDlg, LPGENT("File transfer denied"), FTS_TEXT);
+					} else if (ack->result == ACKRESULT_FAILED)
+					{
+						dat->fs=NULL; // protocol will free structure
+						SkinPlaySound("FileFailed");
+						SetFtStatus(hwndDlg, LPGENT("File transfer failed"), FTS_TEXT);
+					} else {
+						SkinPlaySound("FileDone");
+						if (dat->send)
+						{
+							dat->fs=NULL; // protocol will free structure
+							SetFtStatus(hwndDlg, LPGENT("Transfer completed."), FTS_TEXT);
+
+							DBEVENTINFO dbei={0};
+							FillSendData( dat, dbei );
+							CallService(MS_DB_EVENT_ADD,(WPARAM)dat->hContact,(LPARAM)&dbei);
+							if (dbei.pBlob)
+								mir_free(dbei.pBlob);
+
+							// remove sent encrypted file
+							for (int i = 0; dat->files[i]; i++) {
+								char *c = mir_u2a(dat->files[i]);
+								remove(c);
+								int l = strrchr(c, '.') - c;
+								dat->files[i][l] = '\0';
+								mir_free(c);
+							}
+							// update file controls
+							SetFilenameControls( hwndDlg, dat, &dat->transferStatus );
+
+							dat->files=NULL;   //protocol library frees this
+						
+						} else {
+							WriteDecryptedFile(dat, dat->transferStatus.currentFileNumber);
+							// update file controls
+							for (int i = 0; dat->files[i]; i++) {
+								char *c = mir_u2a(dat->files[i]);
+								int l = strrchr(c, '.') - c;
+								dat->files[i][l] = '\0';
+								mir_free(c);
+							}
+							SetFilenameControls( hwndDlg, dat, &dat->transferStatus );
+
+							SetFtStatus(hwndDlg,
+								(dat->transferStatus.totalFiles == 1) ?
+								LPGENT("Transfer completed, open file.") :
+								LPGENT("Transfer completed, open folder."),
+								FTS_OPEN);
+
+							int useScanner=DBGetContactSettingByte(NULL,"SRFile","UseScanner",VIRUSSCAN_DISABLE);
+							if (useScanner!=VIRUSSCAN_DISABLE) {
+								struct virusscanthreadstartinfo *vstsi;
+								vstsi=(struct virusscanthreadstartinfo*)mir_alloc(sizeof(struct virusscanthreadstartinfo));
+								vstsi->hwndReply=hwndDlg;
+								if(useScanner==VIRUSSCAN_DURINGDL) {
+									vstsi->returnCode=dat->transferStatus.currentFileNumber;
+									if ( GetFileAttributes(dat->files[dat->transferStatus.currentFileNumber])&FILE_ATTRIBUTE_DIRECTORY) {
+										PostMessage(hwndDlg,M_VIRUSSCANDONE,vstsi->returnCode,0);
+										mir_free(vstsi);
+										vstsi=NULL;
+									}
+									else vstsi->szFile = mir_tstrdup(dat->files[dat->transferStatus.currentFileNumber]);
+								}
+								else {
+									vstsi->szFile = mir_tstrdup(dat->transferStatus.tszWorkingDir);
+									vstsi->returnCode = -1;
+								}
+								SetFtStatus(hwndDlg, LPGENT("Scanning for viruses..."), FTS_TEXT);
+								if(vstsi) forkthread((void (*)(void*))RunVirusScannerThread,0,vstsi);
+							} else {
+								dat->fs=NULL; // protocol will free structure
+							}
+							dat->transferStatus.currentFileNumber=dat->transferStatus.totalFiles;
+						} // else dat->send
+						
+					} // else ack->result
+					
+					PostMessage(GetParent(hwndDlg), WM_FT_COMPLETED, ack->result, (LPARAM)hwndDlg);
+					break;
+			}
+			break;
+		} // switch ack->result
+		} break; // case HM_RECVEVENT
+		case M_VIRUSSCANDONE:
+		{	
+			int done=1,i;
+			if((int)wParam==-1) {
+				for(i=0;i<dat->transferStatus.totalFiles;i++) dat->fileVirusScanned[i]=1;
+			}
+			else {
+				dat->fileVirusScanned[wParam]=1;
+				for(i=0;i<dat->transferStatus.totalFiles;i++) if(!dat->fileVirusScanned[i]) {done=0; break;}
+			}
+			if (done)
+			{
+				dat->fs=NULL; // protocol will free structure
+				SetFtStatus(hwndDlg, LPGENT("Transfer and virus scan complete"), FTS_TEXT);
+			}
+			break;
+		}
+		case WM_SIZE:
+		{
+			UTILRESIZEDIALOG urd={0};
+			urd.cbSize=sizeof(urd);
+			urd.hwndDlg=hwndDlg;
+			urd.hInstance=hInst;
+			urd.lpTemplate=MAKEINTRESOURCEA(IDD_FILETRANSFERINFO);
+			urd.pfnResizer=FileTransferDlgResizer;
+			CallService(MS_UTILS_RESIZEDIALOG,0,(LPARAM)&urd);
+
+			RedrawWindow(GetDlgItem(hwndDlg, IDC_ALLTRANSFERRED), NULL, NULL, RDW_INVALIDATE|RDW_NOERASE);
+			RedrawWindow(GetDlgItem(hwndDlg, IDC_ALLSPEED), NULL, NULL, RDW_INVALIDATE|RDW_NOERASE);
+			RedrawWindow(GetDlgItem(hwndDlg, IDC_CONTACTNAME), NULL, NULL, RDW_INVALIDATE|RDW_NOERASE);
+			RedrawWindow(GetDlgItem(hwndDlg, IDC_STATUS), NULL, NULL, RDW_INVALIDATE|RDW_NOERASE);
+			break;
+		}
+		case WM_DESTROY:
+			KillTimer(hwndDlg, 1);
+
+			HFONT hFont = (HFONT)SendDlgItemMessage(hwndDlg,IDC_CONTACTNAME,WM_GETFONT,0,0);
+			DeleteObject(hFont);
+
+			Button_FreeIcon_IcoLib(hwndDlg, IDC_CONTACT);
+			Button_FreeIcon_IcoLib(hwndDlg, IDC_OPENFILE);
+			Button_FreeIcon_IcoLib(hwndDlg, IDCANCEL);
+
+			FreeFileDlgData(dat);
+			break;
+	}
+
+	return FALSE;
+}
+
+void FreeFileDlgData( FileDlgData* dat )
+{
+	if(dat->fs)
+		CallContactService(dat->hContact,PSS_FILECANCEL,(WPARAM)dat->fs,0);
+	dat->fs = NULL;
+
+	if (dat->hPreshutdownEvent) UnhookEvent(dat->hPreshutdownEvent);
+	if (dat->hNotifyEvent) UnhookEvent(dat->hNotifyEvent);
+	dat->hNotifyEvent = NULL;
+
+	FreeProtoFileTransferStatus(&dat->transferStatus);
+	FreeFilesMatrix(&dat->files);
+
+	mir_free(dat->fileVirusScanned);
+	Safe_DestroyIcon(dat->hIcon);
+	Safe_DestroyIcon(dat->hIconFolder);
+	mir_free(dat);
+}
+#endif
\ No newline at end of file
Index: MirOTR/ftmanager.cpp
===================================================================
--- MirOTR/ftmanager.cpp	(revision 0)
+++ MirOTR/ftmanager.cpp	(revision 0)
@@ -0,0 +1,639 @@
+/*
+
+Miranda IM: the free IM client for Microsoft* Windows*
+
+Copyright 2000-2009 Miranda ICQ/IM project,
+all portions of this codebase are copyrighted to the people
+listed in contributors.txt.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+*/
+#ifdef _OTR_SEND_FILE
+#include "stdafx.h"
+#include <iostream>
+#include <fstream>
+static HWND hwndFtMgr = NULL;
+
+struct TFtMgrData
+{
+	HWND hwndIncoming;
+	HWND hwndOutgoing;
+
+	HANDLE hhkPreshutdown;
+	TBPFLAG         errorState;
+};
+
+
+#define M_CALCPROGRESS (WM_USER + 200)
+struct TFtProgressData
+{
+	unsigned int init, run, scan;
+	unsigned __int64 totalBytes, totalProgress;
+};
+
+struct TLayoutWindowInfo
+{
+	HWND hwnd;
+	RECT rc;
+};
+
+struct TLayoutWindowList
+{
+	struct TLayoutWindowInfo **items;
+	int realCount, limit, increment;
+	FSortFunc sortFunc;
+};
+
+struct TFtPageData
+{
+	struct TLayoutWindowList *wnds;
+	int runningCount;
+	int height, dataHeight, scrollPos;
+};
+
+static void LayoutTransfers(HWND hwnd, struct TFtPageData *dat)
+{
+	int top = 0;
+	RECT rc;
+	GetClientRect(hwnd, &rc);
+
+	dat->scrollPos = GetScrollPos(hwnd, SB_VERT);
+	dat->height = rc.bottom - rc.top;
+
+	if (dat->wnds->realCount)
+	{
+		int i;
+		HDWP hdwp;
+
+		hdwp = BeginDeferWindowPos(dat->wnds->realCount);
+		top -= dat->scrollPos;
+		for (i = 0; i < dat->wnds->realCount; ++i)
+		{
+			int height = dat->wnds->items[i]->rc.bottom - dat->wnds->items[i]->rc.top;
+			hdwp = DeferWindowPos(hdwp, dat->wnds->items[i]->hwnd, NULL, 0, top, rc.right, height, SWP_NOZORDER);
+			top += height;
+		}
+		top += dat->scrollPos;
+		EndDeferWindowPos(hdwp);
+	}
+
+	dat->dataHeight = top;
+
+	{
+		SCROLLINFO si = {0};
+		si.cbSize = sizeof(si);
+		si.fMask = SIF_DISABLENOSCROLL|SIF_PAGE|SIF_RANGE;
+		si.nPage = dat->height;
+		si.nMin = 0;
+		si.nMax = dat->dataHeight;
+		SetScrollInfo(hwnd, SB_VERT, &si, TRUE);
+	}
+}
+
+static INT_PTR CALLBACK FtMgrPageDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
+{
+	struct TFtPageData *dat = (struct TFtPageData *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
+
+	switch (msg)
+	{
+	case WM_INITDIALOG:
+	{
+		// Force scrollbar visibility
+		SCROLLINFO si = {0};
+		si.cbSize = sizeof(si);
+		si.fMask = SIF_DISABLENOSCROLL;
+		SetScrollInfo(hwnd, SB_VERT, &si, TRUE);
+
+		dat = (struct TFtPageData *)mir_alloc(sizeof(struct TFtPageData));
+		dat->wnds = (struct TLayoutWindowList *)List_Create(0, 1);
+		dat->scrollPos = 0;
+		dat->runningCount = 0;
+		SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)dat);
+		break;
+	}
+
+	case WM_FT_ADD:
+	{
+		struct TLayoutWindowInfo *wnd = (struct TLayoutWindowInfo *)mir_alloc(sizeof(struct TLayoutWindowInfo));
+		wnd->hwnd = (HWND)lParam;
+		GetWindowRect(wnd->hwnd, &wnd->rc);
+		List_Insert((SortedList *)dat->wnds, wnd, dat->wnds->realCount);
+		LayoutTransfers(hwnd, dat);
+		dat->runningCount++;
+		PostMessage(GetParent(hwnd), WM_TIMER, 1, NULL);
+		break;
+	}
+
+	case WM_FT_RESIZE:
+	{
+		int i;
+		for (i = 0; i < dat->wnds->realCount; ++i)
+			if (dat->wnds->items[i]->hwnd == (HWND)lParam)
+			{
+				GetWindowRect(dat->wnds->items[i]->hwnd, &dat->wnds->items[i]->rc);
+				break;
+			}
+		LayoutTransfers(hwnd, dat);
+		break;
+	}
+
+	case WM_FT_REMOVE:
+	{
+		int i;
+		for (i = 0; i < dat->wnds->realCount; ++i)
+			if (dat->wnds->items[i]->hwnd == (HWND)lParam)
+			{
+				mir_free(dat->wnds->items[i]);
+				List_Remove((SortedList *)dat->wnds, i);
+				break;
+			}
+		LayoutTransfers(hwnd, dat);
+		break;
+	}
+
+ 	case WM_FT_COMPLETED:
+ 	{ //wParam: { ACKRESULT_SUCCESS | ACKRESULT_FAILED | ACKRESULT_DENIED }
+ 		dat->runningCount--;
+		int i = 0;
+		while (i < dat->wnds->realCount)
+		{
+			// no error when canceling (WM_FT_REMOVE is send first, check if hwnd is still registered)
+			if (dat->wnds->items[i]->hwnd == (HWND)lParam)
+			{
+				SendMessage(GetParent(hwnd), WM_TIMER, 1, (LPARAM)wParam);
+				break;
+			}
+			++i;
+		}
+		if (i == dat->wnds->realCount)
+			PostMessage(GetParent(hwnd), WM_TIMER, 1, NULL);
+	
+ 		if(dat->runningCount == 0 && (int)wParam == ACKRESULT_SUCCESS && DBGetContactSettingByte(NULL,"SRFile","AutoClose",0))
+ 			ShowWindow(hwndFtMgr, SW_HIDE);
+ 		break;
+ 	}
+
+	case WM_FT_CLEANUP:
+	{
+		int i;
+		for (i = 0; i < dat->wnds->realCount; ++i)
+			SendMessage(dat->wnds->items[i]->hwnd, WM_FT_CLEANUP, wParam, lParam);
+		break;
+	}
+
+	case WM_SIZE:
+	{
+		LayoutTransfers(hwnd, dat);
+		break;
+	}
+
+	case WM_MOUSEWHEEL:
+	{
+		int zDelta = GET_WHEEL_DELTA_WPARAM(wParam);
+		if (zDelta)
+		{
+			int i, nScrollLines = 0;
+			SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, (void*)&nScrollLines, 0);
+			for (i = 0; i < (nScrollLines + 1) / 2; i++ )
+				SendMessage(hwnd, WM_VSCROLL, (zDelta < 0) ? SB_LINEDOWN : SB_LINEUP, 0);
+		}
+
+		SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
+		return TRUE;
+	}
+
+	case WM_VSCROLL:
+	{
+		int pos = dat->scrollPos;
+		switch (LOWORD(wParam))
+		{
+		case SB_LINEDOWN:
+			pos += 15;
+			break;
+		case SB_LINEUP:
+			pos -= 15;
+			break;
+		case SB_PAGEDOWN:
+			pos += dat->height - 10;
+			break;
+		case SB_PAGEUP:
+			pos -= dat->height - 10;
+			break;
+		case SB_THUMBTRACK:
+			pos = HIWORD(wParam);
+			break;
+		}
+
+		if (pos > dat->dataHeight - dat->height) pos = dat->dataHeight - dat->height;
+		if (pos < 0) pos = 0;
+
+		if (dat->scrollPos != pos)
+		{
+			ScrollWindow(hwnd, 0, dat->scrollPos - pos, NULL, NULL);
+			SetScrollPos(hwnd, SB_VERT, pos, TRUE);
+			dat->scrollPos = pos;
+		}
+		break;
+	}
+
+	case M_PRESHUTDOWN:
+	{
+		int i;
+		for (i = 0; i < dat->wnds->realCount; ++i)
+			PostMessage(dat->wnds->items[i]->hwnd, WM_COMMAND, MAKEWPARAM(IDCANCEL, BN_CLICKED), 0);
+		break;
+	}
+
+	case WM_DESTROY:
+	{
+		int i;
+		for (i = 0; i < dat->wnds->realCount; ++i)
+			mir_free(dat->wnds->items[i]);
+		List_Destroy((SortedList *)dat->wnds);
+		mir_free(dat->wnds);
+		mir_free(dat);
+		break;
+	}
+
+	case M_CALCPROGRESS:
+	{
+		int i;
+		TFtProgressData * prg = (TFtProgressData *)wParam;
+		for (i = 0; i < dat->wnds->realCount; ++i)
+		{
+			struct FileDlgData *trdat = (struct FileDlgData *)GetWindowLongPtr(dat->wnds->items[i]->hwnd, GWLP_USERDATA);
+			if (trdat->transferStatus.totalBytes && trdat->fs && !trdat->send && (trdat->transferStatus.totalBytes == trdat->transferStatus.totalProgress))
+			{
+				prg->scan++;
+			} else if (trdat->transferStatus.totalBytes && trdat->fs)
+			{ // in progress
+				prg->run++;
+				prg->totalBytes += trdat->transferStatus.totalBytes;
+				prg->totalProgress += trdat->transferStatus.totalProgress;
+			} else if (trdat->fs) 
+			{ // starting
+				prg->init++;
+			}
+
+		}
+	}
+	}
+
+	return FALSE;
+}
+
+static INT_PTR CALLBACK FtMgrDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
+{
+	struct TFtMgrData *dat = (struct TFtMgrData *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
+	switch (msg)
+	{
+	case WM_INITDIALOG:
+	{
+		TCITEM tci = {0};
+		HWND hwndTab = GetDlgItem(hwnd, IDC_TABS);
+
+		TranslateDialogDefault(hwnd);
+		Window_SetIcon_IcoLib(hwnd, "core_main_3"); // event file
+
+		dat = (struct TFtMgrData *)mir_calloc(sizeof(struct TFtMgrData));
+
+		SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)dat);
+
+		dat->hhkPreshutdown = HookEventMessage(ME_SYSTEM_PRESHUTDOWN, hwnd, M_PRESHUTDOWN);
+
+		dat->hwndIncoming = CreateDialog(hInst, MAKEINTRESOURCE(IDD_FTPAGE), hwnd, FtMgrPageDlgProc);
+		dat->hwndOutgoing = CreateDialog(hInst, MAKEINTRESOURCE(IDD_FTPAGE), hwnd, FtMgrPageDlgProc);
+		ShowWindow(dat->hwndIncoming, SW_SHOW);
+
+		tci.mask = TCIF_PARAM|TCIF_TEXT;
+		tci.pszText = TranslateT("Incoming");
+		tci.lParam = (LPARAM)dat->hwndIncoming;
+		TabCtrl_InsertItem(hwndTab, 0, &tci);
+		tci.pszText = TranslateT("Outgoing");
+		tci.lParam = (LPARAM)dat->hwndOutgoing;
+		TabCtrl_InsertItem(hwndTab, 1, &tci);
+
+		// Utils_RestoreWindowPosition(hwnd, NULL, "SRFile", "FtMgrDlg_");
+		SAVEWINDOWPOS swp;
+		swp.hwnd=hwnd; swp.hContact=NULL; swp.szModule="ESRFile"; swp.szNamePrefix="FtMgrDlg_";
+		CallService(MS_UTILS_RESTOREWINDOWPOSITION, RWPF_NOACTIVATE, (LPARAM)&swp);
+
+		// Fall through to setup initial placement
+	}
+	case WM_SIZE:
+	{
+		RECT rc, rcButton;
+		HDWP hdwp;
+		HWND hwndTab = GetDlgItem(hwnd, IDC_TABS);
+
+		GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rcButton);
+		OffsetRect(&rcButton, -rcButton.left, -rcButton.top);
+
+		GetClientRect(hwnd, &rc);
+		InflateRect(&rc, -6, -6);
+
+		hdwp = BeginDeferWindowPos(3);
+
+		hdwp = DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_CLEAR), NULL, rc.left, rc.bottom-rcButton.bottom, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
+		hdwp = DeferWindowPos(hdwp, GetDlgItem(hwnd, IDCANCEL), NULL, rc.right-rcButton.right, rc.bottom-rcButton.bottom, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
+
+		rc.bottom -= rcButton.bottom + 5;
+
+		hdwp = DeferWindowPos(hdwp, hwndTab, NULL, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, SWP_NOZORDER);
+
+		EndDeferWindowPos(hdwp);
+
+		GetWindowRect(hwndTab, &rc);
+		MapWindowPoints(NULL, hwnd, (LPPOINT)&rc, 2);
+		TabCtrl_AdjustRect(hwndTab, FALSE, &rc);
+		InflateRect(&rc, -5, -5);
+
+		hdwp = BeginDeferWindowPos(2);
+
+		hdwp = DeferWindowPos(hdwp, dat->hwndIncoming, HWND_TOP, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, 0);
+		hdwp = DeferWindowPos(hdwp, dat->hwndOutgoing, HWND_TOP, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, 0);
+
+		EndDeferWindowPos(hdwp);
+
+		break;
+	}
+
+	case WM_MOUSEWHEEL:
+	{
+		if (IsWindowVisible(dat->hwndIncoming)) SendMessage(dat->hwndIncoming, msg, wParam, lParam);
+		if (IsWindowVisible(dat->hwndOutgoing)) SendMessage(dat->hwndOutgoing, msg, wParam, lParam);
+		break;
+	}
+
+	case WM_FT_SELECTPAGE:
+	{
+		TCITEM tci = {0};
+		HWND hwndTab = GetDlgItem(hwnd, IDC_TABS);
+
+		if (TabCtrl_GetCurSel(hwndTab) == (int)wParam) break;
+
+		tci.mask = TCIF_PARAM;
+
+		TabCtrl_GetItem(hwndTab, TabCtrl_GetCurSel(hwndTab), &tci);
+		ShowWindow((HWND)tci.lParam, SW_HIDE);
+
+		TabCtrl_SetCurSel(hwndTab, wParam);
+
+		TabCtrl_GetItem(hwndTab, TabCtrl_GetCurSel(hwndTab), &tci);
+		ShowWindow((HWND)tci.lParam, SW_SHOW);
+
+		break;
+	}
+
+	case WM_GETMINMAXINFO:
+	{
+		LPMINMAXINFO lpmmi = (LPMINMAXINFO)lParam;
+		lpmmi->ptMinTrackSize.x = 300;
+		lpmmi->ptMinTrackSize.y = 400;
+		return 0;
+	}
+
+	case WM_COMMAND:
+		switch (LOWORD(wParam))
+		{
+			case IDCANCEL:
+				PostMessage(hwnd, WM_CLOSE , 0, 0);
+				break;
+
+			case IDC_CLEAR:
+				PostMessage(dat->hwndIncoming, WM_FT_CLEANUP, 0, 0);
+				PostMessage(dat->hwndOutgoing, WM_FT_CLEANUP, 0, 0);
+				break;
+		}
+		break;
+
+	case WM_NOTIFY:
+	{
+		switch (((LPNMHDR)lParam)->idFrom)
+		{
+		case IDC_TABS:
+		{
+			HWND hwndTab = GetDlgItem(hwnd, IDC_TABS);
+			switch (((LPNMHDR)lParam)->code)
+			{
+			case TCN_SELCHANGING:
+			{
+				TCITEM tci = {0};
+				tci.mask = TCIF_PARAM;
+				TabCtrl_GetItem(hwndTab, TabCtrl_GetCurSel(hwndTab), &tci);
+				ShowWindow((HWND)tci.lParam, SW_HIDE);
+				break;
+			}
+
+			case TCN_SELCHANGE:
+			{
+				TCITEM tci = {0};
+				tci.mask = TCIF_PARAM;
+				TabCtrl_GetItem(hwndTab, TabCtrl_GetCurSel(hwndTab), &tci);
+				ShowWindow((HWND)tci.lParam, SW_SHOW);
+				break;
+			}
+			}
+			break;
+		}
+		}
+		break;
+	}
+
+	case M_PRESHUTDOWN:
+		SendMessage(dat->hwndIncoming, M_PRESHUTDOWN, 0, 0);
+		SendMessage(dat->hwndOutgoing, M_PRESHUTDOWN, 0, 0);
+		DestroyWindow(hwnd);
+		break;
+
+	case WM_CLOSE:
+		ShowWindow(hwnd, SW_HIDE);
+		if (DBGetContactSettingByte(NULL, "SRFile", "AutoClear", 1)) {
+			PostMessage(dat->hwndIncoming, WM_FT_CLEANUP, 0, 0);
+			PostMessage(dat->hwndOutgoing, WM_FT_CLEANUP, 0, 0);
+		}
+		return TRUE; /* Disable default IDCANCEL notification */
+
+	case WM_DESTROY:
+		UnhookEvent(dat->hhkPreshutdown);
+		Window_FreeIcon_IcoLib(hwnd);
+		DestroyWindow(dat->hwndIncoming);
+		DestroyWindow(dat->hwndOutgoing);
+		mir_free(dat);
+		SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);
+		Utils_SaveWindowPosition(hwnd, NULL, "ESRFile", "FtMgrDlg_");
+		break;
+
+	case WM_ACTIVATE:
+	{
+		dat->errorState = TBPF_NOPROGRESS;
+		wParam = 1;
+	} break;
+	case WM_SHOWWINDOW:
+	{
+		if (!wParam) // hiding
+		{
+			KillTimer(hwnd, 1);
+			break;
+		}
+		lParam = 0;
+	}
+	case WM_TIMER:
+	{
+		if (pTaskbarInterface)
+		{
+			SetTimer(hwnd, 1, 400, NULL);
+			if ((lParam == ACKRESULT_FAILED) || (lParam == ACKRESULT_DENIED))
+				dat->errorState = TBPF_ERROR;
+
+			TFtProgressData prg = {0};
+			SendMessage(dat->hwndIncoming, M_CALCPROGRESS, (WPARAM)&prg, 0);
+			SendMessage(dat->hwndOutgoing, M_CALCPROGRESS, (WPARAM)&prg, 0);
+			if (dat->errorState)
+			{
+				pTaskbarInterface->SetProgressState(hwnd, dat->errorState);
+				if (!prg.run)
+					pTaskbarInterface->SetProgressValue(hwnd, 1, 1);
+			} else if (prg.run) 
+			{
+				pTaskbarInterface->SetProgressState(hwnd, TBPF_NORMAL);
+			} else if (prg.init || prg.scan)
+			{
+				pTaskbarInterface->SetProgressState(hwnd, TBPF_INDETERMINATE);
+			} else {
+				pTaskbarInterface->SetProgressState(hwnd, TBPF_NOPROGRESS);
+				KillTimer(hwnd, 1);
+			}
+
+			if (prg.run)
+			{
+				pTaskbarInterface->SetProgressValue(hwnd, prg.totalProgress, prg.totalBytes);	
+			}				
+
+		}
+	} break;
+
+	}
+
+	return FALSE;
+}
+
+HWND FtMgr_Show(bool bForceActivate, bool bFromMenu)
+{
+	bool bAutoMin = DBGetContactSettingByte(NULL,"SRFile","AutoMin",0) != 0; /* lqbe */
+
+ 	bool bJustCreated = (hwndFtMgr == NULL);
+ 	if (bJustCreated)
+ 	{
+ 		hwndFtMgr = CreateDialog(hInst, MAKEINTRESOURCE(IDD_FTMGR), NULL, FtMgrDlgProc);
+ 		ShowWindow(hwndFtMgr, SW_SHOW);
+ 	}
+	if (bFromMenu) /* lqbe */
+ 	{
+		ShowWindow(hwndFtMgr, SW_RESTORE);
+ 		ShowWindow(hwndFtMgr, SW_SHOW);
+ 		SetForegroundWindow(hwndFtMgr);
+ 		return hwndFtMgr;
+ 	}
+	else if (bAutoMin && bJustCreated) /* lqbe */
+ 	{
+ 		ShowWindow(hwndFtMgr, SW_HIDE);
+ 		ShowWindow(hwndFtMgr, SW_MINIMIZE);
+		return hwndFtMgr;
+ 	}
+	else if (bForceActivate) /* lqbe */
+	{
+		ShowWindow(hwndFtMgr, SW_RESTORE);
+		ShowWindow(hwndFtMgr, SW_SHOWNOACTIVATE);
+		SetForegroundWindow(hwndFtMgr);
+ 		return hwndFtMgr;
+	}
+	if (!bJustCreated && IsWindowVisible(hwndFtMgr))
+		return hwndFtMgr;
+ 
+	ShowWindow(hwndFtMgr, bAutoMin ? SW_SHOWMINNOACTIVE : SW_SHOWNOACTIVATE);
+  	return hwndFtMgr;
+ }
+
+void FtMgr_Destroy()
+{
+	if (hwndFtMgr)
+		DestroyWindow(hwndFtMgr);
+}
+
+void FtMgr_ShowPage(int page)
+{
+	if (hwndFtMgr)
+		SendMessage(hwndFtMgr, WM_FT_SELECTPAGE, page, 0);
+}
+
+HWND FtMgr_AddTransfer(FileDlgData *fdd)
+{
+	using namespace std;
+
+	bool bForceActivate = fdd->send || !DBGetContactSettingByte(NULL, "SRFile", "AutoAccept", 0);
+	TFtMgrData *dat = (TFtMgrData*)GetWindowLongPtr(FtMgr_Show(bForceActivate, false), GWLP_USERDATA);
+
+	// encrypt files, send them
+	if (fdd->send) {
+		for (int i = 0; fdd->files[i]; i++ ) {
+			ifstream file (fdd->files[i], ios::in|ios::binary|ios::ate);
+			if (file.is_open())
+			{
+				int size = file.tellg();
+				char* memblock = new char [size];
+				file.seekg (0, ios::beg);
+				file.read (memblock, size);
+				file.close();
+
+				gcry_error_t err;
+				char *newmessage = 0;
+				char *proto = (char *)CallService(MS_PROTO_GETCONTACTBASEPROTO, (WPARAM)fdd->hContact, 0);
+				char *username = contact_get_id(fdd->hContact);
+				err = otrl_message_sending(otr_user_state, &ops, (void*)fdd->hContact,
+					proto, proto, username, memblock, NULL, &newmessage,
+					add_appdata, (void*)fdd->hContact, size);
+				mir_free(username);
+
+				if (err && newmessage == NULL) {
+					ShowError(TranslateT(LANG_ENCRYPTION_ERROR));
+				} else if (newmessage) {
+					char newfile[1024];
+					char *f = mir_u2a(fdd->files[i]);
+					mir_snprintf(newfile, SIZEOF(newfile), "%s.enc", f);
+					mir_free(f);
+					mir_free(fdd->files[i]); // free old buffer, write new buffer
+					fdd->files[i] = mir_a2u(newfile);
+
+					ofstream encfile(newfile, ios::out|ios::binary);
+					encfile.write(newmessage, strlen(newmessage));
+					encfile.close();
+					otrl_message_free(newmessage);
+				}
+
+				delete[] memblock;
+			}
+		}
+	}
+
+
+	HWND hwndBox = fdd->send ? dat->hwndOutgoing : dat->hwndIncoming;
+	HWND hwndFt = CreateDialogParam(hInst, MAKEINTRESOURCE(IDD_FILETRANSFERINFO), hwndBox, DlgProcFileTransfer, (LPARAM)fdd);
+	ShowWindow(hwndFt, SW_SHOWNA);
+	SendMessage(hwndBox, WM_FT_ADD, 0, (LPARAM)hwndFt);
+	FtMgr_ShowPage(fdd->send ? 1 : 0);
+	return hwndFt;
+}
+#endif
\ No newline at end of file
Index: MirOTR/language.h
===================================================================
--- MirOTR/language.h	(revision 4)
+++ MirOTR/language.h	(working copy)
@@ -17,6 +17,7 @@
 #define LANG_MENU_START						LPGEN("&Start OTR session")
 #define LANG_MENU_REFRESH					LPGEN("&Refresh OTR session")
 #define LANG_MENU_STOP						LPGEN("Sto&p OTR session")
+#define LANG_MENU_SENDFILE						LPGEN("S&end file")
 #define LANG_MENU_VERIFY					LPGEN("&Verify Fingerprint")
 
 #define LANG_SESSION_TERMINATED_OTR			LPGEN("OTR encrypted session with '%s' has been terminated")
Index: MirOTR/MirOTR.vcproj
===================================================================
--- MirOTR/MirOTR.vcproj	(revision 4)
+++ MirOTR/MirOTR.vcproj	(working copy)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="9,00"
+	Version="9.00"
 	Name="MirOTR"
 	ProjectGUID="{53F841E8-284F-4545-9176-B131896E43F8}"
 	RootNamespace="MirOTR"
@@ -117,7 +117,7 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				AdditionalOptions="/D &quot;_CRT_SECURE_NO_WARNINGS&quot; /D &quot;_CRT_NON_CONFORMING_SWPRINTFS&quot;"
+				AdditionalOptions="/D &quot;_CRT_SECURE_NO_WARNINGS&quot; /D &quot;_CRT_NON_CONFORMING_SWPRINTFS&quot; /D &quot;_OTR_SEND_FILE&quot;"
 				Optimization="3"
 				InlineFunctionExpansion="1"
 				EnableIntrinsicFunctions="true"
@@ -281,77 +281,137 @@
 				>
 			</File>
 			<File
-				RelativePath=".\DLG_smp.cpp"
+				RelativePath=".\dllmain.cpp"
 				>
 				<FileConfiguration
 					Name="Debug|Win32"
-					ExcludedFromBuild="true"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+						CompileAsManaged="0"
 					/>
 				</FileConfiguration>
 				<FileConfiguration
 					Name="Release|Win32"
-					ExcludedFromBuild="true"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+						CompileAsManaged="0"
 					/>
 				</FileConfiguration>
 				<FileConfiguration
 					Name="Release ANSI|Win32"
-					ExcludedFromBuild="true"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+						CompileAsManaged="0"
 					/>
 				</FileConfiguration>
 			</File>
 			<File
-				RelativePath=".\dllmain.cpp"
+				RelativePath=".\file.cpp"
 				>
 				<FileConfiguration
-					Name="Debug|Win32"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
 						UsePrecompiledHeader="0"
-						CompileAsManaged="0"
 					/>
 				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\fileexistsdlg.cpp"
+				>
 				<FileConfiguration
 					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
 						UsePrecompiledHeader="0"
-						CompileAsManaged="0"
 					/>
 				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\fileopts.cpp"
+				>
 				<FileConfiguration
-					Name="Release ANSI|Win32"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
 						UsePrecompiledHeader="0"
-						CompileAsManaged="0"
 					/>
 				</FileConfiguration>
 			</File>
 			<File
+				RelativePath=".\filerecvdlg.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\filesenddlg.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\filexferdlg.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\ftmanager.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
 				RelativePath=".\icons.cpp"
 				>
 			</File>
 			<File
 				RelativePath=".\mirotrmenu.cpp"
 				>
+			</File>
+			<File
+				RelativePath=".\misc.c"
+				>
 				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
 					/>
 				</FileConfiguration>
 			</File>
@@ -426,6 +486,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\file.h"
+				>
+			</File>
+			<File
 				RelativePath=".\icons.h"
 				>
 			</File>
@@ -487,34 +551,6 @@
 				RelativePath=".\resources\resource.rc"
 				>
 			</File>
-			<File
-				RelativePath=".\resources\version.rc"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCResourceCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCResourceCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release ANSI|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCResourceCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
 		</Filter>
 		<File
 			RelativePath=".\ReadMe.txt"
Index: MirOTR/mirotrmenu.cpp
===================================================================
--- MirOTR/mirotrmenu.cpp	(revision 4)
+++ MirOTR/mirotrmenu.cpp	(working copy)
@@ -255,7 +255,14 @@
 	mi.pszService = MS_OTR_MENUSTOP;
 	mi.icolibItem = GetIconHandle(ICON_NOT_PRIVATE);
 	AddMirOTRMenuItem(0, (LPARAM) &mi);
-
+/*
+	mi.flags = CMIF_TCHAR|CMIF_ICONFROMICOLIB|CMIF_NOTNOTPRIVATE;
+	mi.ptszName = _T(LANG_MENU_SENDFILE);
+	mi.position = 100004;
+	mi.pszService = MS_OTR_MENUSENDFILE;
+	mi.icolibItem = GetIconHandle(ICON_NOT_PRIVATE);
+	AddMirOTRMenuItem(0, (LPARAM) &mi);
+*/
 	mi.flags = CMIF_TCHAR|CMIF_ICONFROMICOLIB|CMIF_NOTNOTPRIVATE|CMIF_NOTFINISHED;
 	mi.ptszName = _T(LANG_MENU_VERIFY);
 	mi.position = 200001;
Index: MirOTR/misc.c
===================================================================
--- MirOTR/misc.c	(revision 0)
+++ MirOTR/misc.c	(revision 0)
@@ -0,0 +1,23 @@
+#ifdef _OTR_SEND_FILE
+#include <windows.h>
+#include <shellapi.h>
+#include <shlobj.h>
+#include <commctrl.h>
+#include <commdlg.h>
+#include <ole2.h>
+
+#include <uxtheme.h>
+#include <vssym32.h>
+
+#include <time.h>
+
+#include <win2k.h>
+
+ITaskbarList3 * pTaskbarInterface;
+
+void createTaskbarInterface(void)
+{
+	    if (IsWinVer7Plus())
+		    CoCreateInstance(&CLSID_TaskbarList, NULL, CLSCTX_ALL, &IID_ITaskbarList3, (void**)&pTaskbarInterface);
+}
+#endif
\ No newline at end of file
Index: MirOTR/options.cpp
===================================================================
--- MirOTR/options.cpp	(revision 4)
+++ MirOTR/options.cpp	(working copy)
@@ -6,7 +6,7 @@
 #include <commctrl.h>
 #include <process.h>
 
-char g_fingerprint_store_filename[MAX_PATH];
+char g_fingerprint_store_filename[MAX_PATH];
 char g_private_key_filename[MAX_PATH];
 HANDLE hPATH_MIROTR;
 Options options;
@@ -728,30 +728,30 @@
 			// Some code to create the list-view control.
 			// Initialize LVITEM members that are common to all
 			// items. 
-			lvI.mask = LVIF_TEXT | LVIF_PARAM;// | LVIF_NORECOMPUTE;// | LVIF_IMAGE; 
-			ConnContext * context = otr_user_state->context_root;
-			TCHAR *proto, *user, hash[45] = {0};
-			Fingerprint *fp;
-			while (context) {
-				if (context->app_data) {
-					user = (TCHAR*)contact_get_nameT((HANDLE)context->app_data);
-					if (user) {
-						proto = mir_a2t(context->protocol);
-						fp = context->fingerprint_root.next;
-						while(fp) {
-							otrl_privkey_hash_to_humanT(hash, fp->fingerprint);
-							if (hash) {
+			lvI.mask = LVIF_TEXT | LVIF_PARAM;// | LVIF_NORECOMPUTE;// | LVIF_IMAGE; 
+			ConnContext * context = otr_user_state->context_root;
+			TCHAR *proto, *user, hash[45] = {0};
+			Fingerprint *fp;
+			while (context) {
+				if (context->app_data) {
+					user = (TCHAR*)contact_get_nameT((HANDLE)context->app_data);
+					if (user) {
+						proto = mir_a2t(context->protocol);
+						fp = context->fingerprint_root.next;
+						while(fp) {
+							otrl_privkey_hash_to_humanT(hash, fp->fingerprint);
+							if (hash) {
 								lvI.iSubItem = 0;
 								lvI.lParam = (LPARAM)fp;
 								lvI.pszText = user;
 								int d = ListView_InsertItem(lv, &lvI);
 
-								ListView_SetItemText(lv,d, 1, proto);
-								ListView_SetItemText(lv,d, 2, (context->active_fingerprint == fp)? TranslateT(LANG_YES) : TranslateT(LANG_NO));
-								ListView_SetItemText(lv,d, 3, (fp->trust && fp->trust != '\0')? TranslateT(LANG_YES) : TranslateT(LANG_NO));
-								ListView_SetItemText(lv,d, 4, hash );
-							}
-							fp = fp->next;
+								ListView_SetItemText(lv,d, 1, proto);
+								ListView_SetItemText(lv,d, 2, (context->active_fingerprint == fp)? TranslateT(LANG_YES) : TranslateT(LANG_NO));
+								ListView_SetItemText(lv,d, 3, (fp->trust && fp->trust != '\0')? TranslateT(LANG_YES) : TranslateT(LANG_NO));
+								ListView_SetItemText(lv,d, 4, hash );
+							}
+							fp = fp->next;
 						}
 						mir_free(proto);
 					}
Index: MirOTR/otr.cpp
===================================================================
--- MirOTR/otr.cpp	(revision 4)
+++ MirOTR/otr.cpp	(working copy)
@@ -329,55 +329,55 @@
 
 // Forward decl
 gcry_error_t otrl_privkey_write_FILEp(OtrlUserState us, FILE *privf);
-/* Generate a private DSA key for a given account, storing it into a
- * file on disk, and loading it into the given OtrlUserState.  Overwrite any
- * previously generated keys for that account in that OtrlUserState. */
-gcry_error_t otrl_privkey_write(OtrlUserState us, const char *filename)
-{
-    gcry_error_t err;
-    FILE *privf;
-#ifndef WIN32
-    mode_t oldmask;
-#endif
-
-#ifndef WIN32
-    oldmask = umask(077);
-#endif
-    privf = fopen(filename, "w+b");
-    if (!privf) {
-#ifndef WIN32
-	umask(oldmask);
-#endif
-	err = gcry_error_from_errno(errno);
-	return err;
-    }
-
-    err = otrl_privkey_write_FILEp(us, privf);
-
-    fclose(privf);
-#ifndef WIN32
-    umask(oldmask);
-#endif
-    return err;
-}
-
-/* Just store the private keys of an OtrlUserState.
- * The FILE* must be open for reading and writing. */
-gcry_error_t otrl_privkey_write_FILEp(OtrlUserState us, FILE *privf)
-{
-    OtrlPrivKey *p;
-
-    if (!privf) return gcry_error(GPG_ERR_NO_ERROR);
-
-    
-
-    /* Output the other keys we know */
-    fprintf(privf, "(privkeys\n");
-    for (p=us->privkey_root; p; p=p->next) {
-		otrl_account_write(privf, p->accountname, p->protocol, p->privkey);
-    }
-    if ( fprintf(privf, ")\n") < 0 )
-		return gcry_error_from_errno(errno);
-	return gcry_error(GPG_ERR_NO_ERROR);
-
+/* Generate a private DSA key for a given account, storing it into a
+ * file on disk, and loading it into the given OtrlUserState.  Overwrite any
+ * previously generated keys for that account in that OtrlUserState. */
+gcry_error_t otrl_privkey_write(OtrlUserState us, const char *filename)
+{
+    gcry_error_t err;
+    FILE *privf;
+#ifndef WIN32
+    mode_t oldmask;
+#endif
+
+#ifndef WIN32
+    oldmask = umask(077);
+#endif
+    privf = fopen(filename, "w+b");
+    if (!privf) {
+#ifndef WIN32
+	umask(oldmask);
+#endif
+	err = gcry_error_from_errno(errno);
+	return err;
+    }
+
+    err = otrl_privkey_write_FILEp(us, privf);
+
+    fclose(privf);
+#ifndef WIN32
+    umask(oldmask);
+#endif
+    return err;
+}
+
+/* Just store the private keys of an OtrlUserState.
+ * The FILE* must be open for reading and writing. */
+gcry_error_t otrl_privkey_write_FILEp(OtrlUserState us, FILE *privf)
+{
+    OtrlPrivKey *p;
+
+    if (!privf) return gcry_error(GPG_ERR_NO_ERROR);
+
+    
+
+    /* Output the other keys we know */
+    fprintf(privf, "(privkeys\n");
+    for (p=us->privkey_root; p; p=p->next) {
+		otrl_account_write(privf, p->accountname, p->protocol, p->privkey);
+    }
+    if ( fprintf(privf, ")\n") < 0 )
+		return gcry_error_from_errno(errno);
+	return gcry_error(GPG_ERR_NO_ERROR);
+
 }
\ No newline at end of file
Index: MirOTR/resource.h
===================================================================
--- MirOTR/resource.h	(revision 4)
+++ MirOTR/resource.h	(working copy)
@@ -91,6 +91,519 @@
 #define IDM_OTR_STOP 10004
 #define IDM_OTR_VERIFY 10005
 
+
+//{{NO_DEPENDENCIES}}
+// Microsoft Visual C++ generated include file.
+// Used by resource.rc
+//
+#define IDC_AUTHICON                    1
+#define IDC_NOTOALL                     3
+#define IDC_APPLY                       3
+#define IDC_DECIDELATER                 3
+#define IDI_MIRANDA                     102
+#define IDD_ABOUT                       103
+#define IDI_SMS                         103
+#define IDI_ONLINE                      104
+#define IDI_OFFLINE                     105
+#define IDD_CUSTOM_FONT                 106
+#define IDD_OPT_FONTS                   107
+#define IDD_OPT_GENMENU                 108
+#define IDD_OPT_PROTOCOLORDER           109
+#define IDD_OPT_ICOLIB                  110
+#define IDD_ICOLIB_IMPORT               111
+#define IDD_MODERNOPT_FONTS             112
+#define IDD_ADDED                       115
+#define IDD_URLSEND                     119
+#define IDD_URLRECV                     120
+#define IDD_AUTHREQ                     121
+#define IDD_DETAILS                     125
+#define IDD_HISTORY                     127
+#define IDI_AWAY                        128
+#define IDI_FREE4CHAT                   129
+#define IDI_INVISIBLE                   130
+#define IDI_NA                          131
+#define IDI_LOAD                        132
+#define IDD_OPT_SOUND                   134
+#define IDI_RECVMSG                     136
+#define IDI_URL                         138
+#define IDD_MODERNOPT_ACCOUNTS          139
+#define IDD_MODERNOPT_MODULES           140
+#define IDD_MODERNOPT_STATUS            141
+#define IDD_MODERNOPT_IDLE              142
+#define IDD_MODERNOPT_IGNORE            143
+#define IDI_DND                         158
+#define IDI_OCCUPIED                    159
+#define IDI_USERDETAILS                 160
+#define IDI_FINDUSER                    161
+#define IDI_HELP                        162
+#define IDI_OPTIONS                     163
+#define IDI_MIRANDAWEBSITE              172
+#define IDI_RENAME                      173
+#define IDI_HISTORY                     174
+#define IDI_DELETE                      175
+#define IDR_ICOLIB_CONTEXT              181
+#define IDC_DROP                        183
+#define IDD_HISTORY_FIND                192
+#define IDI_SENDEMAIL                   193
+#define IDD_FILERECV                    194
+#define IDD_PROFILEMANAGER              197
+#define IDR_CLISTMENU                   199
+#define IDI_BLANK                       200
+#define IDD_FINDADD                     201
+#define IDI_USERONLINE                  201
+#define IDI_GROUPSHUT                   202
+#define IDD_OPTIONS                     203
+#define IDI_GROUPOPEN                   203
+#define IDD_FILESEND                    205
+#define IDI_NOTICK                      205
+#define IDD_OPT_PLUGINS                 206
+#define IDI_TICK                        206
+#define IDD_OPT_ICONS                   207
+#define IDI_FILE                        207
+#define IDI_ADDCONTACT                  210
+#define IDI_SMALLDOT                    211
+#define IDI_FILLEDBLOB                  212
+#define IDD_READAWAYMSG                 213
+#define IDI_EMPTYBLOB                   213
+#define IDD_OPT_IGNORE                  214
+#define IDC_HYPERLINKHAND               214
+#define IDD_OPT_VISIBILITY              215
+#define IDC_DROPUSER                    215
+#define IDD_SETAWAYMSG                  216
+#define IDI_DETAILSLOGO                 216
+#define IDD_OPT_AWAYMSG                 217
+#define IDI_UNICODE                     218
+#define IDI_ANSI                        219
+#define IDD_INFO_SUMMARY                220
+#define IDI_LOADED                      220
+#define IDD_INFO_CONTACT                221
+#define IDR_CREDITS                     221
+#define IDI_NOTLOADED                   221
+#define IDD_INFO_BACKGROUND             222
+#define IDD_INFO_NOTES                  223
+#define IDD_ADDEMAIL                    226
+#define IDD_ICONINDEX                   227
+#define IDD_INFO_LOCATION               231
+#define IDD_INFO_WORK                   232
+#define IDD_ADDPHONE                    233
+#define IDD_INSTALLINI                  235
+#define IDD_WARNINICHANGE               236
+#define IDD_INIIMPORTDONE               237
+#define IDB_SORTCOLUP                   239
+#define IDB_SORTCOLDOWN                 240
+#define IDD_OPT_NETLIB                  246
+#define IDD_NETLIBLOGOPTS               247
+#define IDD_FILETRANSFERINFO            249
+#define IDD_OPT_FILETRANSFER            250
+#define IDD_FILEEXISTS                  251
+#define IDD_DELETECONTACT               254
+#define IDD_ADDCONTACT                  257
+#define IDD_OPT_CONTACT                 261
+#define IDI_DOWNARROW                   264
+#define IDD_OPT_IDLE                    268
+#define IDD_PROFILE_SELECTION           269
+#define IDD_PROFILE_NEW                 270
+#define IDI_TYPING                      274
+#define IDD_UPDATE_NOTIFY               275
+#define IDD_OPT_UPDATENOTIFY            276
+#define IDD_OPT_KEYBINDINGS             277
+#define IDD_OPT_HOTKEYS                 278
+#define IDI_UNDO                        279
+#define IDI_WINDOW                      280
+#define IDI_WINDOWS                     281
+#define IDI_ACCMGR                      282
+#define IDD_ACCMGR                      283
+#define IDD_ACCFORM                     284
+#define IDD_WAITRESTART                 285
+#define IDD_FTMGR                       286
+#define IDD_FTPAGE                      287
+#define IDD_OPT_KEYWORDFILTER           288
+#define IDI_JOINCHAT                    289
+#define IDD_CHOOSE_FONT_EFFECT          289
+#define IDI_LEAVECHAT                   290
+#define IDI_STATUS_LOCKED               291
+#define IDI_SHOWHIDE                    292
+#define IDI_EXIT                        293
+#define IDD_ERROR_LIST                  300
+#define IDD_OPT_ERRORS                  301
+#define IDD_OPTIONSPAGE                 318
+#define IDI_MOVETOGROUP                 319
+#define IDI_ON                          320
+#define IDI_OFF                         322
+#define IDC_SAVE                        1001
+#define IDI_ONTHEPHONE                  1002
+#define IDC_MESSAGE                     1002
+#define IDI_OUTTOLUNCH                  1003
+#define IDC_AUTOCLOSE                   1004
+#define IDC_FROM                        1005
+#define IDC_AUTOMIN                     1005
+#define IDC_DATE                        1006
+#define IDC_DUMPRECV                    1006
+#define IDC_AUTOCLEAR                   1007
+#define IDC_MSG                         1008
+#define IDC_PROXYDNS                    1008
+#define IDC_NAME                        1009
+#define IDC_PROXYTYPE                   1009
+#define IDC_STATIC23                    1010
+#define IDC_NAMEVAL                     1010
+#define IDC_LNK_NETWORK                 1010
+#define IDC_LNK_ADDONS                  1011
+#define IDC_SPECIFYPORTS                1013
+#define IDC_ST_ENTERMSG                 1013
+#define IDC_ST_ENTERURL                 1014
+#define IDC_SPECIFYPORTSO               1014
+#define IDC_ENABLEUPNP                  1015
+#define IDC_VALIDATESSL                 1016
+#define IDC_SHOWNAMES                   1024
+#define IDC_ABOUT                       1032
+#define IDC_MYNOTES                     1033
+#define IDC_URLS                        1037
+#define IDC_REPLY                       1039
+#define IDC_URL                         1041
+#define IDC_FONTGROUP                   1042
+#define IDC_BTN_RESET                   1045
+#define IDC_REASON                      1046
+#define IDC_BTN_UNDO                    1047
+#define IDC_DENYREASON                  1047
+#define IDC_EMAIL                       1048
+#define IDC_NAMENICK                    1049
+#define IDC_NAMEFIRST                   1050
+#define IDC_NAMELAST                    1051
+#define IDC_NICK                        1053
+#define IDC_BTN_EXPORT                  1054
+#define IDC_FONTLIST                    1056
+#define IDC_CHOOSEFONT                  1057
+#define IDC_EFFECT                      1058
+#define IDC_EFFECT_STATIC               1059
+#define IDC_GENDER                      1060
+#define IDC_CITY                        1061
+#define IDC_STATE                       1062
+#define IDC_COUNTRY                     1063
+#define IDC_AGE                         1064
+#define IDC_ZIP                         1064
+#define IDC_PHONE                       1065
+#define IDC_STREET                      1065
+#define IDC_COMPANY                     1066
+#define IDC_LANGUAGE1                   1066
+#define IDC_TIMEZONE                    1067
+#define IDC_DEPARTMENT                  1067
+#define IDC_LOCALTIME                   1068
+#define IDC_DETAILS                     1069
+#define IDC_POSITION                    1069
+#define IDC_LANGUAGE2                   1069
+#define IDC_ADD                         1070
+#define IDC_LANGUAGE3                   1070
+#define IDC_MOREOPTIONS                 1071
+#define IDC_USERMENU                    1071
+#define IDC_EDIT                        1078
+#define IDC_LIST                        1079
+#define IDC_HISTORY                     1080
+#define IDC_MENUOBJECTS                 1081
+#define IDC_MENUITEMS                   1082
+#define IDC_NOTSUPPORTWARNING           1083
+#define IDC_INSERTSEPARATOR             1084
+#define IDC_GENMENU_SERVICE             1085
+#define IDC_GENMENU_CUSTOMNAME          1086
+#define IDC_GENMENU_SET                 1087
+#define IDC_GENMENU_DEFAULT             1089
+#define IDC_CANVAS                      1094
+#define IDC_CANVAS2                     1095
+#define IDC_BUILDTIME                   1108
+#define IDC_CREDITSFILE                 1109
+#define IDC_NUMBER                      1113
+#define IDC_FINDWHAT                    1131
+#define IDC_FIND                        1132
+#define IDC_FILE                        1133
+#define IDC_PROFILELIST                 1134
+#define IDC_EFFECT_COMBO                1140
+#define IDC_TABS                        1141
+#define IDC_RESULTS                     1142
+#define IDC_STATUS                      1144
+#define IDC_USEPROXY                    1148
+#define IDC_PROXYAUTH                   1149
+#define IDC_PROXYHOST                   1150
+#define IDC_PROXYPORT                   1151
+#define IDC_PROXYUSER                   1152
+#define IDC_PROXYPASS                   1153
+#define IDC_STATIC12                    1155
+#define IDC_STATIC21                    1156
+#define IDC_STATIC22                    1157
+#define IDC_STATIC31                    1158
+#define IDC_STATIC32                    1159
+#define IDC_CHANGE                      1164
+#define IDC_PREVIEW                     1165
+#define IDC_CHOOSE                      1169
+#define IDC_TO                          1170
+#define IDC_VERSION                     1179
+#define IDC_ICONSET                     1183
+#define IDC_BROWSE                      1184
+#define IDC_RUNATSTARTBROWSE            1185
+#define IDC_PAGETREE                    1186
+#define IDC_RUNNOW                      1186
+#define IDC_RETRIEVING                  1193
+#define IDC_GETMORE                     1200
+#define IDC_VISIBLEICON                 1204
+#define IDC_INVISIBLEICON               1205
+#define IDC_FILEICON                    1206
+#define IDC_ONLINEICON                  1207
+#define IDC_FILENAMES                   1208
+#define IDC_ALLICON                     1208
+#define IDC_DONTREPLY                   1209
+#define IDC_NONEICON                    1209
+#define IDC_USEPREVIOUS                 1210
+#define IDC_TYPINGICON                  1210
+#define IDC_NODIALOG                    1211
+#define IDC_USESPECIFIC                 1212
+#define IDC_FILEDIR                     1213
+#define IDC_TRANSFERCOMPLETED           1214
+#define IDC_ALLFILESPROGRESS            1217
+#define IDC_WHITERECT                   1221
+#define IDC_ALLSPEED                    1221
+#define IDC_FIRSTNAME                   1224
+#define IDC_LASTNAME                    1225
+#define IDC_DOBDAY                      1226
+#define IDC_DOBMONTH                    1227
+#define IDC_WEBPAGE                     1228
+#define IDC_DOBYEAR                     1228
+#define IDC_UPDATING                    1231
+#define IDC_NAMEORDER                   1234
+#define IDC_RECONNECTREQD               1239
+#define IDC_IMPORT                      1241
+#define IDC_TOMAIN                      1243
+#define IDC_TOPROTO                     1244
+#define IDC_PROTOLIST                   1245
+#define IDC_TODEFICON                   1246
+#define IDC_IMPORTMULTI                 1247
+#define IDC_EFFECT_COLOUR1              1266
+#define IDC_BKGCOLOUR                   1269
+#define IDC_EFFECT_COLOUR2              1269
+#define IDC_FILENAME                    1271
+#define IDC_FONTCOLOUR                  1282
+#define IDC_INTERESTS                   1305
+#define IDC_EMAILS                      1306
+#define IDC_PAST                        1307
+#define IDC_PHONES                      1308
+#define IDC_SMS                         1310
+#define IDC_AREA                        1312
+#define IDC_UPDATE                      1313
+#define IDC_ININAME                     1333
+#define IDC_VIEWINI                     1334
+#define IDC_SECURITYINFO                1335
+#define IDC_SETTINGNAME                 1336
+#define IDC_NEWVALUE                    1337
+#define IDC_WARNNOMORE                  1338
+#define IDC_DELETE                      1339
+#define IDC_RECYCLE                     1340
+#define IDC_NEWNAME                     1341
+#define IDC_MOVE                        1342
+#define IDC_LEAVE                       1343
+#define IDC_EXPERT                      1346
+#define IDC_CATEGORYLIST                1366
+#define IDC_LOADICONS                   1369
+#define IDC_STICONSGROUP                1371
+#define IDC_MSGICON                     1375
+#define IDC_URLICON                     1376
+#define IDC_STNOPAGE                    1377
+#define IDC_STCHECKMARKS                1380
+#define IDC_STATUSBAR                   1389
+#define IDC_PROTOIDGROUP                1392
+#define IDC_BYPROTOID                   1393
+#define IDC_PROTOID                     1394
+#define IDC_EMAILGROUP                  1395
+#define IDC_BYEMAIL                     1396
+#define IDC_STNAMENICK                  1397
+#define IDC_NAMEGROUP                   1398
+#define IDC_BYNAME                      1399
+#define IDC_STNAMEFIRST                 1400
+#define IDC_STNAMELAST                  1401
+#define IDC_ADVANCEDGROUP               1402
+#define IDC_BYADVANCED                  1403
+#define IDC_ADVANCED                    1404
+#define IDC_PROTOCOLORDER               1405
+#define IDC_TINYEXTENDEDGROUP           1406
+#define IDC_RESETPROTOCOLDATA           1407
+#define IDC_BYCUSTOM                    1408
+#define IDC_PROTOCOLORDERWARNING        1409
+#define IDC_STSIMPLERIGHT               1440
+#define IDC_NETLIBUSERS                 1443
+#define IDC_STOFTENPORT                 1445
+#define IDC_STATIC52                    1447
+#define IDC_STATIC43                    1448
+#define IDC_LOGOPTIONS                  1449
+#define IDC_PORTSRANGE                  1450
+#define IDC_PORTSRANGEO                 1452
+#define IDC_STATIC54                    1453
+#define IDC_TOOUTPUTDEBUGSTRING         1455
+#define IDC_TOFILE                      1456
+#define IDC_RUNATSTART                  1458
+#define IDC_DUMPSENT                    1464
+#define IDC_DUMPPROXY                   1466
+#define IDC_TEXTDUMPS                   1467
+#define IDC_AUTODETECTTEXT              1468
+#define IDC_TIMEFORMAT                  1469
+#define IDC_FILENAMEBROWSE              1470
+#define IDC_SHOWTHISDLGATSTART          1471
+#define IDC_DUMPSSL                     1473
+#define IDC_FILEDIRBROWSE               1475
+#define IDC_SCANCMDLINEBROWSE           1476
+#define IDC_ALLTRANSFERRED              1477
+#define IDC_OPENFOLDER                  1478
+#define IDC_OPENFILE                    1479
+#define IDC_TOTALSIZE                   1480
+#define IDC_CONTACT                     1480
+#define IDC_AUTOACCEPT                  1484
+#define IDC_SCANCMDLINE                 1485
+#define IDC_WARNBEFOREOPENING           1488
+#define IDC_SCANDURINGDL                1489
+#define IDC_SCANAFTERDL                 1490
+#define IDC_NOSCANNER                   1491
+#define IDC_ST_CMDLINE                  1492
+#define IDC_ST_CMDLINEHELP              1493
+#define IDC_PROPERTIES                  1496
+#define IDC_RESUME                      1497
+#define IDC_EXISTINGICON                1499
+#define IDC_RESUMEALL                   1500
+#define IDC_OVERWRITE                   1501
+#define IDC_OVERWRITEALL                1502
+#define IDC_SKIP                        1503
+#define IDC_EXISTINGSIZE                1506
+#define IDC_EXISTINGDATE                1507
+#define IDC_EXISTINGTYPE                1508
+#define IDC_NEWICON                     1509
+#define IDC_NEWSIZE                     1510
+#define IDC_NEWDATE                     1511
+#define IDC_NEWTYPE                     1512
+#define IDC_SAVEAS                      1513
+#define IDC_AUTORENAME                  1514
+#define IDC_ASK                         1516
+#define IDC_RENAME                      1519
+#define IDC_VIRUSSCANNERGROUP           1520
+#define IDC_HIDE                        1534
+#define IDC_TOPLINE                     1535
+#define IDC_MYHANDLE                    1540
+#define IDC_GROUP                       1541
+#define IDC_ADDED                       1542
+#define IDC_AUTH                        1543
+#define IDC_DELETEHISTORY               1560
+#define IDC_AUTHREQ                     1577
+#define IDC_AUTHGB                      1578
+#define IDC_PROTOCOL                    1580
+#define IDC_CONTRIBLINK                 1586
+#define IDC_DEVS                        1589
+#define IDC_TXT_TITLE1                  1592
+#define IDC_TXT_TITLE2                  1593
+#define IDC_TXT_TITLE3                  1594
+#define IDC_TXT_TITLE4                  1595
+#define IDC_TXT_TITLE5                  1596
+#define IDC_TXT_TITLE6                  1597
+#define IDC_TXT_TITLE7                  1598
+#define IDC_TXT_TITLE8                  1599
+#define IDC_PREVIEWSMALL                1600
+#define IDC_PREVIEWGENERAL              1601
+#define IDC_PREVIEWHEADER               1602
+#define IDC_CHOOSEFONTHEADER            1603
+#define IDC_CHOOSEFONTGENERAL           1604
+#define IDC_CHOOSEFONTSMALL             1605
+#define IDC_IDLEONWINDOWS               1637
+#define IDC_IDLEONMIRANDA               1638
+#define IDC_SCREENSAVER                 1642
+#define IDC_LOCKED                      1643
+#define IDC_IDLESHORT                   1644
+#define IDC_UPGRADE                     1645
+#define IDC_FULLSCREEN                  1645
+#define IDC_IDLE1STTIME                 1646
+#define IDC_IDLEPRIVATE                 1649
+#define IDC_AASTATUS                    1650
+#define IDC_AASHORTIDLE                 1651
+#define IDC_SOUNDTREE                   1657
+#define IDC_LOCATION                    1659
+#define IDC_SGROUP                      1660
+#define IDC_SLOC                        1661
+#define IDC_PROFILENAME                 1673
+#define IDC_PROFILEDRIVERS              1674
+#define IDC_PLUGLIST                    1676
+#define IDC_PLUGINLONGINFO              1677
+#define IDC_PLUGINAUTHOR                1679
+#define IDC_PLUGININFOFRAME             1680
+#define IDC_PLUGINCPYR                  1681
+#define IDC_PLUGINURL                   1682
+#define IDC_PLUGINPID                   1683
+#define IDC_PLUGINEMAIL                 1684
+#define IDC_IDLESPIN                    1687
+#define IDC_NODBDRIVERS                 1690
+#define IDC_IDLESTATUSLOCK              1691
+#define IDC_RESTART                     1692
+#define IDC_TAB                         1693
+#define IDC_IDLETERMINAL                1694
+#define IDC_ENABLESOUNDS                1695
+#define IDC_NEWVERSIONLABEL             1696
+#define IDC_CURRENTVERSION              1697
+#define IDC_DOWNLOAD                    1699
+#define IDC_ENABLEUPDATES               1700
+#define IDC_ENABLEALPHA                 1701
+#define IDC_RESETMENU                   1702
+#define IDC_KEYWORD_FILTER              1704
+#define IDC_FILTER                      1706
+#define IDC_PATH                        1707
+#define IDC_LV_HOTKEYS                  1708
+#define IDC_HOTKEY                      1709
+#define IDC_SM_COMBO                    1710
+#define IDC_SM_LABEL                    1711
+#define IDC_REMOVE                      1712
+#define IDC_ACCLIST                     1713
+#define IDC_ACCNAME                     1714
+#define IDC_PROTOTYPECOMBO              1715
+#define IDC_ACCINTERNALNAME             1716
+#define IDC_OPTIONS                     1717
+#define IDC_CLEAR                       1718
+#define IDC_PROGRESSBAR                 1719
+#define IDC_TXT_ACCOUNT                 1720
+#define IDC_TXT_ADDITIONAL              1721
+#define IDC_TXT_INFO                    1722
+#define IDC_CONTACTNAME                 1724
+#define IDC_FRAME                       1725
+#define IDC_LST_STATUS                  1726
+#define IDC_ALLPRECENTS                 1727
+#define IDC_ENABLE_KEYWORDFILTERING     1729
+#define IDC_BKGCOLOUR_STATIC            1730
+#define IDC_LST_ERRORS                  1731
+#define IDC_LV_ERRORS                   1733
+#define IDC_HEADERBAR                   1734
+#define IDC_LV_LEGEND                   1735
+#define IDC_ENABLEBETA                  1737
+#define IDC_ENABLESTABLE                1738
+#define IDC_STORELASTPROFILE            1739
+#define IDC_RADIO1                      1740
+#define IDC_RADIO2                      1741
+#define IDC_EFFECT_COLOUR_TEXT1         1853
+#define IDC_EFFECT_COLOUR_SPIN1         1854
+#define IDC_EFFECT_COLOUR_TEXT2         11803
+#define IDC_EFFECT_COLOUR_SPIN2         11806
+#define IDI_SEARCHALL                   32548
+#define ID_ICQ_EXIT                     40001
+#define IDM_COPY                        40001
+#define ID_RESET                        40002
+#define POPUP_HIDEEMPTYGROUPS           40003
+#define POPUP_NEWSUBGROUP               40004
+#define POPUP_HIDEOFFLINE               40005
+#define POPUP_GROUPHIDEOFFLINE          40006
+#define POPUP_HIDEOFFLINEROOT           40007
+#define POPUP_DISABLEGROUPS             40008
+#define IDC_SENDMESSAGE                 40009
+#define IDM_COPYALL                     40011
+#define IDM_SELECTALL                   40012
+#define IDM_CLEAR                       40013
+#define IDM_OPENNEW                     40014
+#define IDM_OPENEXISTING                40015
+#define IDM_COPYLINK                    40016
+#define POPUP_HIDEMIRANDA               40017
+#define ID_CANCELCHANGE                 40018
+#define ID_TRAY_HIDE                    40038
+#define ID_TRAY_EXIT                    40040
+#define POPUP_NEWGROUP                  40050
+#define POPUP_RENAMEGROUP               40052
+#define POPUP_DELETEGROUP               40053
+
 // Next default values for new objects
 // 
 #ifdef APSTUDIO_INVOKED
Index: MirOTR/resources/resource.rc
===================================================================
--- MirOTR/resources/resource.rc	(revision 4)
+++ MirOTR/resources/resource.rc	(working copy)
@@ -50,6 +50,170 @@
   CONTROL "Show verification dialog when receiving unverified fingerprint",IDC_CHK_AUTOSHOW_VERIFY,"Button",WS_VISIBLE|WS_TABSTOP|BS_AUTOCHECKBOX,12,154,265,10
 END
 
+IDD_FILESEND DIALOGEX 0, 0, 256, 177
+STYLE DS_SETFONT | DS_MODALFRAME | DS_SETFOREGROUND | DS_3DLOOK | DS_FIXEDSYS | DS_CENTER | WS_MINIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CLIPCHILDREN | WS_CAPTION | WS_SYSMENU
+EXSTYLE WS_EX_CONTROLPARENT
+CAPTION "Send File(s)"
+FONT 8, "MS Shell Dlg", 0, 0, 0x1
+BEGIN
+    EDITTEXT        IDC_MSG,6,102,245,46,ES_MULTILINE | ES_AUTOVSCROLL | ES_WANTRETURN | WS_VSCROLL
+    DEFPUSHBUTTON   "&Send",IDOK,67,157,50,15
+    PUSHBUTTON      "Cancel",IDCANCEL,140,157,50,15
+    LTEXT           "To:",IDC_STATIC,6,23,24,9,SS_CENTERIMAGE
+    CONTROL         "",IDC_TO,"Static",SS_SIMPLE | SS_NOPREFIX | WS_GROUP,43,24,159,9
+    LTEXT           "File(s):",IDC_STATIC,7,39,30,8
+    EDITTEXT        IDC_FILE,38,38,213,31,ES_MULTILINE | ES_AUTOVSCROLL | ES_READONLY
+    PUSHBUTTON      "&Choose Again...",IDC_CHOOSE,39,74,77,14
+    RTEXT           "Total size:",IDC_STATIC,119,76,68,8
+    CONTROL         "",IDC_TOTALSIZE,"Static",SS_SIMPLE | SS_NOPREFIX | WS_GROUP,191,76,58,8
+    LTEXT           "Description:",IDC_STATIC,6,93,96,8
+    CONTROL         "6",IDC_USERMENU,"MButtonClass",WS_TABSTOP,195,5,16,14,WS_EX_NOACTIVATE | 0x10000000L
+    CONTROL         "&D",IDC_DETAILS,"MButtonClass",WS_TABSTOP,213,5,16,14,WS_EX_NOACTIVATE | 0x10000000L
+    CONTROL         "&H",IDC_HISTORY,"MButtonClass",WS_TABSTOP,231,5,16,14,WS_EX_NOACTIVATE | 0x10000000L
+    CONTROL         "",IDC_PROTOCOL,"Button",BS_OWNERDRAW | WS_TABSTOP,5,7,12,12
+    LTEXT           "",IDC_NAME,19,7,151,9,SS_NOPREFIX | SS_CENTERIMAGE
+END
+
+IDD_FILERECV DIALOGEX 0, 0, 256, 174
+STYLE DS_SETFONT | DS_MODALFRAME | DS_SETFOREGROUND | DS_FIXEDSYS | DS_CENTER | WS_MINIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CLIPCHILDREN | WS_CAPTION | WS_SYSMENU
+EXSTYLE WS_EX_CONTROLPARENT
+CAPTION "Incoming Encrypted File Transfer"
+FONT 8, "MS Shell Dlg", 0, 0, 0x1
+BEGIN
+    DEFPUSHBUTTON   "A&ccept",IDOK,68,155,50,14
+    PUSHBUTTON      "&Decline",IDCANCEL,138,155,50,14
+    LTEXT           "From:",IDC_STATIC,6,20,24,9,SS_CENTERIMAGE
+    CONTROL         "",IDC_FROM,"Static",SS_SIMPLE | SS_NOPREFIX | WS_GROUP,39,21,159,9
+    LTEXT           "Date:",IDC_STATIC,6,35,28,9,SS_CENTERIMAGE
+    CONTROL         "",IDC_DATE,"Static",SS_SIMPLE | SS_NOPREFIX | WS_GROUP,39,34,159,9
+    LTEXT           "Files:",IDC_STATIC,6,50,28,8
+    EDITTEXT        IDC_FILENAMES,39,50,210,16,ES_MULTILINE | ES_AUTOVSCROLL | ES_READONLY | NOT WS_BORDER
+    LTEXT           "Description:",IDC_STATIC,6,69,64,8
+    EDITTEXT        IDC_MSG,6,79,243,45,ES_MULTILINE | ES_AUTOVSCROLL | ES_READONLY
+    LTEXT           "Save to:",IDC_STATIC,6,131,34,8
+    PUSHBUTTON      "...",IDC_FILEDIRBROWSE,235,130,14,10
+    COMBOBOX        IDC_FILEDIR,45,129,187,108,CBS_DROPDOWN | CBS_AUTOHSCROLL | WS_VSCROLL | WS_TABSTOP
+    CONTROL         "&A",IDC_ADD,"MButtonClass",WS_TABSTOP,177,5,16,14,WS_EX_NOACTIVATE | 0x10000000L
+    CONTROL         "6",IDC_USERMENU,"MButtonClass",WS_TABSTOP,195,5,16,14,WS_EX_NOACTIVATE | 0x10000000L
+    CONTROL         "&D",IDC_DETAILS,"MButtonClass",WS_TABSTOP,213,5,16,14,WS_EX_NOACTIVATE | 0x10000000L
+    CONTROL         "&H",IDC_HISTORY,"MButtonClass",WS_TABSTOP,231,5,16,14,WS_EX_NOACTIVATE | 0x10000000L
+    CONTROL         "",IDC_PROTOCOL,"Button",BS_OWNERDRAW | WS_TABSTOP,5,7,12,12
+    LTEXT           "",IDC_NAME,19,7,151,9,SS_NOPREFIX | SS_CENTERIMAGE
+END
+
+IDD_OPT_FILETRANSFER DIALOGEX 0, 0, 313, 232
+STYLE DS_SETFONT | DS_FIXEDSYS | WS_CHILD | WS_VISIBLE
+EXSTYLE WS_EX_CONTROLPARENT
+FONT 8, "MS Shell Dlg", 0, 0, 0x1
+BEGIN
+    GROUPBOX        "Receiving files",IDC_STATIC,0,0,313,90
+    LTEXT           "Received files folder:",IDC_STATIC,8,15,82,8
+    EDITTEXT        IDC_FILEDIR,92,13,190,12,ES_AUTOHSCROLL
+    PUSHBUTTON      "...",IDC_FILEDIRBROWSE,287,14,15,11
+    LTEXT           "Variables Allowed: %userid%, %nick%, %proto%, %miranda_path%, %userprofile%",IDC_STATIC,8,27,294,11,WS_DISABLED
+    CONTROL         "Auto-accept incoming files from people on my contact list",IDC_AUTOACCEPT,
+                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,39,294,10
+    CONTROL         "Minimize the file transfer window",IDC_AUTOMIN,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,17,52,285,10
+    CONTROL         "Close window when transfer completes",IDC_AUTOCLOSE,
+                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,65,294,10
+    CONTROL         "Clear completed transfers on window closing",IDC_AUTOCLEAR,
+                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,76,294,10
+    GROUPBOX        "Virus scanner",IDC_VIRUSSCANNERGROUP,0,90,313,93
+    LTEXT           "Scan files:",IDC_STATIC,8,102,43,9,SS_CENTERIMAGE
+    CONTROL         "Never, do not use virus scanning",IDC_NOSCANNER,"Button",BS_AUTORADIOBUTTON,52,102,250,10
+    CONTROL         "When all files have been downloaded",IDC_SCANAFTERDL,
+                    "Button",BS_AUTORADIOBUTTON,52,114,250,10
+    CONTROL         "As each file finishes downloading",IDC_SCANDURINGDL,
+                    "Button",BS_AUTORADIOBUTTON,52,126,250,10
+    LTEXT           "Command line:",IDC_ST_CMDLINE,7,142,62,8
+    COMBOBOX        IDC_SCANCMDLINE,70,141,213,71,CBS_DROPDOWN | CBS_AUTOHSCROLL | CBS_SORT | WS_VSCROLL | WS_TABSTOP
+    PUSHBUTTON      "...",IDC_SCANCMDLINEBROWSE,287,142,15,11
+    LTEXT           "%f will be replaced by the file or folder name to be scanned",IDC_ST_CMDLINEHELP,70,155,232,8
+    CONTROL         "Warn me before opening a file that has not been scanned",IDC_WARNBEFOREOPENING,
+                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,8,168,294,10
+    GROUPBOX        "If incoming files already exist",IDC_STATIC,0,187,313,41
+    CONTROL         "Ask me",IDC_ASK,"Button",BS_AUTORADIOBUTTON,8,200,73,10
+    CONTROL         "Resume",IDC_RESUME,"Button",BS_AUTORADIOBUTTON,82,200,125,10
+    CONTROL         "Overwrite",IDC_OVERWRITE,"Button",BS_AUTORADIOBUTTON,8,212,73,10
+    CONTROL         "Rename (append "" (1)"", etc.)",IDC_RENAME,"Button",BS_AUTORADIOBUTTON,82,212,125,10
+    LTEXT           "You will always be asked about files from people not on your contact list",IDC_STATIC,212,198,90,24
+END
+
+IDD_FILETRANSFERINFO DIALOGEX 0, 0, 256, 44
+STYLE DS_SETFONT | DS_3DLOOK | DS_FIXEDSYS | WS_CHILD
+EXSTYLE WS_EX_CONTROLPARENT
+FONT 8, "MS Shell Dlg", 0, 0, 0x1
+BEGIN
+    CONTROL         "Contact menu",IDC_CONTACT,"MButtonClass",WS_TABSTOP,5,1,16,14,WS_EX_NOACTIVATE | 0x10000000L
+    CONTROL         "",IDC_CONTACTNAME,"Static",SS_LEFTNOWORDWRAP | SS_CENTERIMAGE | SS_WORDELLIPSIS | WS_GROUP,25,1,174,14
+    CONTROL         "Open...",IDC_OPENFILE,"MButtonClass",WS_DISABLED | WS_TABSTOP,203,1,16,14,WS_EX_NOACTIVATE | 0x10000000L
+    CONTROL         "Open folder",IDC_OPENFOLDER,"MButtonClass",WS_TABSTOP,219,1,16,14,WS_EX_NOACTIVATE | 0x10000000L
+    CONTROL         "Cancel",IDCANCEL,"MButtonClass",WS_TABSTOP,235,1,16,14,WS_EX_NOACTIVATE | 0x10000000L
+    CONTROL         "",IDC_ALLFILESPROGRESS,"msctls_progress32",PBS_SMOOTH | NOT WS_VISIBLE | WS_DISABLED,25,16,190,12
+    CONTROL         "",IDC_STATUS,"Static",SS_LEFTNOWORDWRAP | SS_NOPREFIX | WS_GROUP,25,17,190,10
+    ICON            "",IDC_FILEICON,25,15,16,14,SS_CENTERIMAGE | SS_REALSIZEIMAGE
+    CONTROL         "Transfer completed, open file(s).",IDC_TRANSFERCOMPLETED,
+                    "Hyperlink",NOT WS_VISIBLE | WS_TABSTOP,42,17,173,10
+    LTEXT           "No data transferred",IDC_ALLTRANSFERRED,25,29,226,14,SS_NOPREFIX | SS_CENTERIMAGE
+    RTEXT           "",IDC_ALLSPEED,25,29,226,14,SS_NOPREFIX | SS_CENTERIMAGE
+    LTEXT           "",IDC_ALLPRECENTS,218,14,33,14,SS_CENTERIMAGE
+    CONTROL         "",IDC_FRAME,"Static",SS_ETCHEDHORZ,1,43,254,1
+END
+
+IDD_FILEEXISTS DIALOGEX 0, 0, 288, 181
+STYLE DS_SETFONT | DS_MODALFRAME | DS_SETFOREGROUND | DS_FIXEDSYS | DS_CENTER | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
+EXSTYLE WS_EX_CONTROLPARENT
+CAPTION "File Already Exists"
+FONT 8, "MS Shell Dlg", 0, 0, 0x1
+BEGIN
+    PUSHBUTTON      "Resume",IDC_RESUME,5,144,65,14
+    PUSHBUTTON      "Resume all",IDC_RESUMEALL,5,162,65,14
+    PUSHBUTTON      "Overwrite",IDC_OVERWRITE,76,144,65,14
+    PUSHBUTTON      "Overwrite all",IDC_OVERWRITEALL,76,162,65,14
+    PUSHBUTTON      "Save as...",IDC_SAVEAS,147,144,65,14
+    PUSHBUTTON      "Auto rename",IDC_AUTORENAME,147,162,65,14
+    PUSHBUTTON      "Skip",IDC_SKIP,218,144,65,14
+    PUSHBUTTON      "Cancel transfer",IDCANCEL,218,162,65,14
+    LTEXT           "You are about to receive the file",IDC_STATIC,5,5,278,8
+    EDITTEXT        IDC_FILENAME,15,16,268,8,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER
+    GROUPBOX        "Existing file",IDC_STATIC,5,29,278,61
+    ICON            "",IDC_EXISTINGICON,14,45,20,20,SS_NOTIFY
+    LTEXT           "Size:",IDC_STATIC,40,42,27,8
+    LTEXT           "",IDC_EXISTINGSIZE,67,42,35,8
+    RTEXT           "Last modified:",IDC_STATIC,103,42,58,8
+    LTEXT           "",IDC_EXISTINGDATE,166,42,115,8
+    LTEXT           "Type:",IDC_STATIC,40,55,27,8
+    LTEXT           "",IDC_EXISTINGTYPE,67,55,214,8
+    PUSHBUTTON      "Open file",IDC_OPENFILE,12,70,62,13
+    PUSHBUTTON      "Open folder",IDC_OPENFOLDER,82,70,62,13
+    PUSHBUTTON      "File properties",IDC_PROPERTIES,201,70,74,13
+    GROUPBOX        "File being received",IDC_STATIC,5,95,278,42
+    ICON            "",IDC_NEWICON,14,110,20,20,SS_NOTIFY
+    LTEXT           "Size:",IDC_STATIC,40,108,27,8
+    LTEXT           "",IDC_NEWSIZE,67,108,35,8
+    RTEXT           "Last modified:",IDC_STATIC,103,108,58,8
+    LTEXT           "",IDC_NEWDATE,166,108,115,8
+    LTEXT           "Type:",IDC_STATIC,40,121,27,8
+    LTEXT           "",IDC_NEWTYPE,67,121,214,8
+END
+
+IDD_FTPAGE DIALOGEX 0, 0, 320, 183
+STYLE DS_SETFONT | DS_FIXEDSYS | WS_CHILD | WS_VSCROLL | WS_SYSMENU
+EXSTYLE WS_EX_CONTROLPARENT | WS_EX_STATICEDGE
+FONT 8, "MS Shell Dlg", 400, 0, 0x1
+BEGIN
+END
+
+IDD_FTMGR DIALOGEX 0, 0, 276, 255
+STYLE DS_SETFONT | DS_FIXEDSYS | DS_CENTER | WS_MINIMIZEBOX | WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
+CAPTION "Encrypted File Transfers"
+FONT 8, "MS Shell Dlg", 400, 0, 0x1
+BEGIN
+    CONTROL         "",IDC_TABS,"SysTabControl32",0x0,7,7,262,224
+    PUSHBUTTON      "Clear completed",IDC_CLEAR,7,234,100,14
+    PUSHBUTTON      "Close",IDCANCEL,219,234,50,14
+END
+
 IDD_OPT_PROTO DIALOGEX 0,0,296,220
 FONT 8,"MS Shell Dlg",0,0,1
 STYLE WS_CHILDWINDOW|WS_VISIBLE|DS_SHELLFONT
@@ -131,3 +295,79 @@
   CONTROL "&Yes",IDYES,"Button",NOT WS_VISIBLE|WS_CHILDWINDOW|WS_TABSTOP,135,180,60,16
 END
 
+/////////////////////////////////////////////////////////////////////////////
+//
+// DESIGNINFO
+//
+
+#ifdef APSTUDIO_INVOKED
+GUIDELINES DESIGNINFO 
+BEGIN
+    IDD_FILESEND, DIALOG
+    BEGIN
+        LEFTMARGIN, 5
+        RIGHTMARGIN, 251
+        VERTGUIDE, 7
+        VERTGUIDE, 249
+        TOPMARGIN, 5
+        BOTTOMMARGIN, 172
+    END
+
+    IDD_FILERECV, DIALOG
+    BEGIN
+        LEFTMARGIN, 5
+        RIGHTMARGIN, 249
+        VERTGUIDE, 7
+        VERTGUIDE, 249
+        TOPMARGIN, 5
+        BOTTOMMARGIN, 169
+    END
+
+    IDD_FILETRANSFERINFO, DIALOG
+    BEGIN
+        VERTGUIDE, 5
+        VERTGUIDE, 25
+        VERTGUIDE, 36
+        VERTGUIDE, 120
+        VERTGUIDE, 180
+        VERTGUIDE, 215
+        VERTGUIDE, 218
+        VERTGUIDE, 235
+        VERTGUIDE, 251
+        BOTTOMMARGIN, 43
+        HORZGUIDE, 14
+        HORZGUIDE, 28
+        HORZGUIDE, 42
+    END
+
+    IDD_FILEEXISTS, DIALOG
+    BEGIN
+        LEFTMARGIN, 5
+        RIGHTMARGIN, 283
+        TOPMARGIN, 5
+        BOTTOMMARGIN, 176
+    END
+
+    IDD_FTPAGE, DIALOG
+    BEGIN
+        LEFTMARGIN, 7
+        RIGHTMARGIN, 303
+        TOPMARGIN, 7
+        BOTTOMMARGIN, 176
+    END
+
+    IDD_OPT_FILETRANSFER, DIALOG
+    BEGIN
+        VERTGUIDE, 8
+        VERTGUIDE, 302
+    END
+
+    IDD_FTMGR, DIALOG
+    BEGIN
+        LEFTMARGIN, 7
+        RIGHTMARGIN, 269
+        TOPMARGIN, 7
+        BOTTOMMARGIN, 248
+    END
+END
+#endif    // APSTUDIO_INVOKED
Index: MirOTR/stdafx.h
===================================================================
--- MirOTR/stdafx.h	(revision 4)
+++ MirOTR/stdafx.h	(working copy)
@@ -10,7 +10,7 @@
 #define WIN32_LEAN_AND_MEAN             // Selten verwendete Teile der Windows-Header nicht einbinden.
 // Windows-Headerdateien:
 #include <windows.h>
-#include <string.h>
+#include <string.h>
 #include <assert.h>
 
 #ifdef _DEBUG
@@ -22,32 +22,79 @@
 	#define DEBUGOUT(x)		
 	#define DEBUGOUT_T(x)	
 #endif
-#define MIRANDA_VER    0x0800
- 
+#define MIRANDA_VER 0x0900
 #include <newpluginapi.h>
+
+
+#define _ALPHA_BASE_ 1	// defined for CVS builds
+#define _ALPHA_FUSE_ 1	// defined for fuse powered core
+
+#define WINVER 0x0700
+#define _WIN32_WINNT 0x0700
+#define _WIN32_IE 0x0601
+
+#include <windows.h>
+#include <windowsx.h>
+#include <shlobj.h>
+#include <uxtheme.h>
+#include <commctrl.h>
+#include <vssym32.h>
+
+#include <stdio.h>
+#include <time.h>
+#include <stddef.h>
+#include <process.h>
+#include <io.h>
+#include <limits.h>
+#include <string.h>
+#include <locale.h>
+#include <direct.h>
+
+#include <win2k.h>
+
 #include <m_system.h>
+#include <m_system_cpp.h>
+#include <newpluginapi.h>
+#include <m_database.h>
+#include <m_clc.h>
+#include <m_clui.h>
 #include <m_langpack.h>
-#include <m_utils.h>
-#include <m_database.h>
-#include <m_folders.h>
 #include <m_clist.h>
+#include <m_clistint.h>
+#include <m_button.h>
+#include <m_protosvc.h>
+#include <m_protomod.h>
+#include <m_protocols.h>
+#include <m_protoint.h>
+#include <m_plugins.h>
+#include <m_options.h>
+#include <m_skin.h>
+#include <m_contacts.h>
 #include <m_message.h>
+#include <m_userinfo.h>
+#include <m_history.h>
+#include <m_addcontact.h>
+#include <m_findadd.h>
+#include <m_file.h>
+#include <m_email.h>
+#include <m_awaymsg.h>
+#include <m_idle.h>
+#include <m_ignore.h>
+#include <m_icolib.h>
+#include <m_modernopt.h>
+#include <m_help.h>
+#include <m_popup.h>
+#include <m_folders.h>
 #include <m_metacontacts.h>
-#include <m_protocols.h>
-#include <m_protomod.h>
-#include <m_protosvc.h>
-#include <m_updater.h>
-#include <m_popup.h>
-#include <m_contacts.h> 
-#include <m_utils.h>
-#include <m_icolib.h>
 
+#include <m_xml.h>
+
 #include <gcrypt.h>
 extern "C" {
-	#include <privkey.h>
-	#include <proto.h>
-	#include <tlv.h>
-	#include <message.h>
+	#include <privkey.h>
+	#include <proto.h>
+	#include <tlv.h>
+	#include <message.h>
 	#include <userstate.h>
 }
 
@@ -62,13 +109,25 @@
 #include "otr.h"
 #include "icons.h"
 #include "dialogs.h"
+#ifdef _OTR_SEND_FILE
+#include "file.h"
+#include <shlobj.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <ShellAPI.h>
+#include <CommDlg.h>
+#include <miranda.h>
+#include <forkthread.h>
+#include <dblists.h>
+#endif
+#include <m_updater.h>
 
 // modified manual policy - so that users set to 'opportunistic' will automatically start OTR with users set to 'manual'
 #define OTRL_POLICY_MANUAL_MOD		(OTRL_POLICY_MANUAL | OTRL_POLICY_WHITESPACE_START_AKE | OTRL_POLICY_ERROR_START_AKE)
 
 // {030F37D6-DD32-434d-BC64-5B6541EB9299}
 static const MUUID MIID_OTR = { 0x30f37d6, 0xdd32, 0x434d, { 0xbc, 0x64, 0x5b, 0x65, 0x41, 0xeb, 0x92, 0x99 } };
-#ifdef _UNICODE
+#ifdef _UNICODE
 	// {12D8FAAD-78AB-4e3c-9854-320E9EA5CC9F}
 	static const MUUID MIID_OTRPLUGIN = { 0x12d8faad, 0x78ab, 0x4e3c, { 0x98, 0x54, 0x32, 0xe, 0x9e, 0xa5, 0xcc, 0x9f } };
 #else
@@ -82,6 +141,8 @@
 #define MS_OTR_MENUSTOP			MODULENAME"/Stop"
 #define MS_OTR_MENUREFRESH		MODULENAME"/Refresh"
 #define MS_OTR_MENUVERIFY		MODULENAME"/Verify"
+#define MS_OTR_MENUSENDFILE		MODULENAME"/Sendfile"
+#define MS_OTR_MENURECVFILE		MODULENAME"/Recvfile"
 
 #define PREF_BYPASS_OTR 0x8000
 #define PREF_NO_HISTORY  0x10000
Index: MirOTR/svcs_menu.h
===================================================================
--- MirOTR/svcs_menu.h	(revision 4)
+++ MirOTR/svcs_menu.h	(working copy)
@@ -3,6 +3,7 @@
 int SVC_RefreshOTR(WPARAM wParam, LPARAM lParam);
 int SVC_StopOTR(WPARAM wParam, LPARAM lParam);
 int SVC_VerifyOTR(WPARAM wParam, LPARAM lParam);
+extern int SVC_SendFileOTR(WPARAM wParam, LPARAM lParam);
 int SVC_PrebuildContactMenu(WPARAM wParam, LPARAM lParam);
 void InitMenu();
 void DeinitMenu();
\ No newline at end of file
Index: MirOTR/svcs_proto.cpp
===================================================================
--- MirOTR/svcs_proto.cpp	(revision 4)
+++ MirOTR/svcs_proto.cpp	(working copy)
@@ -15,7 +15,7 @@
 	char *proto = (char *)CallService(MS_PROTO_GETCONTACTBASEPROTO, (WPARAM)ccs->hContact, 0);
 	if(proto && g_metaproto && strcmp(proto, g_metaproto) == 0) // bypass for metacontacts
 		return CallService(MS_PROTO_CHAINSEND, wParam, lParam);
-	char *username = contact_get_id(ccs->hContact);
+	char *username = contact_get_id(ccs->hContact);
 	if(!proto || !username) return 1; // error
 
 	gcry_error_t err;
@@ -43,41 +43,41 @@
 		if (!(ccs->wParam & PREF_UTF)) mir_free(oldmessage_utf);
 		return CallService(MS_PROTO_CHAINSEND, wParam, lParam);
 	}
-
-    err = otrl_message_sending(otr_user_state, &ops, (void*)ccs->hContact,
-	    proto, proto, username, oldmessage_utf, NULL, &newmessage,
-	    add_appdata, (void*)ccs->hContact);
-	if (!(ccs->wParam & PREF_UTF)) mir_free(oldmessage_utf);
-	oldmessage_utf = NULL;
-	mir_free(username);
-
-    if (err && newmessage == NULL) {
-	/* Be *sure* not to send out plaintext */
-		ShowError(TranslateT(LANG_ENCRYPTION_ERROR));
-		/* should not be needed
-		char t[3] = {0, 0, 0};
+
+    err = otrl_message_sending(otr_user_state, &ops, (void*)ccs->hContact,
+	    proto, proto, username, oldmessage_utf, NULL, &newmessage,
+	    add_appdata, (void*)ccs->hContact, strlen(oldmessage_utf));
+	if (!(ccs->wParam & PREF_UTF)) mir_free(oldmessage_utf);
+	oldmessage_utf = NULL;
+	mir_free(username);
+
+    if (err && newmessage == NULL) {
+	/* Be *sure* not to send out plaintext */
+		ShowError(TranslateT(LANG_ENCRYPTION_ERROR));
+		/* should not be needed
+		char t[3] = {0, 0, 0};
 		if(ccs->wParam & PREF_UNICODE) { //TODO!! lstrlen(pre->szMessage)+1 ??
 			if (strlen(oldmessage)) memcpy(oldmessage, t,3 );
 		} else {
 			if (strlen(oldmessage)) memcpy(oldmessage, t, 1);
-		}
-		*/
-		return 1;
-    } else if (newmessage) {
-	/* Fragment the message if necessary, and send all but the last
-	 * fragment over the network.  We will send the last segment later */
-		ConnContext *context = otrl_context_find_miranda(otr_user_state,
-			(void*)ccs->hContact);
-
-		// oldmessage_utf is not used anymore, so use it as buffer
-		err = otrl_message_fragment_and_send(&ops, (void*)ccs->hContact, context,
-		newmessage, OTRL_FRAGMENT_SEND_ALL_BUT_LAST, &oldmessage_utf);
-		// newmessage is not needed anymore
-		otrl_message_free(newmessage);
-		// move the last fragment to newmessage, oldmessage_utf will be buffer later
-		newmessage = oldmessage_utf;
-
-		WPARAM oldflags = ccs->wParam;
+		}
+		*/
+		return 1;
+    } else if (newmessage) {
+	/* Fragment the message if necessary, and send all but the last
+	 * fragment over the network.  We will send the last segment later */
+		ConnContext *context = otrl_context_find_miranda(otr_user_state,
+			(void*)ccs->hContact);
+
+		// oldmessage_utf is not used anymore, so use it as buffer
+		err = otrl_message_fragment_and_send(&ops, (void*)ccs->hContact, context,
+		newmessage, OTRL_FRAGMENT_SEND_ALL_BUT_LAST, &oldmessage_utf);
+		// newmessage is not needed anymore
+		otrl_message_free(newmessage);
+		// move the last fragment to newmessage, oldmessage_utf will be buffer later
+		newmessage = oldmessage_utf;
+
+		WPARAM oldflags = ccs->wParam;
 		if(ccs->wParam & PREF_UTF) {
 			ccs->lParam = (LPARAM)newmessage;
 		} else if(ccs->wParam & PREF_UNICODE) {
@@ -90,23 +90,23 @@
 		} else {
 			 mir_utf8decode(newmessage, NULL);
 			 ccs->lParam = (LPARAM)newmessage;
-		}
-		if (otr_context_get_trust(context) >= TRUST_UNVERIFIED) ccs->wParam;
-		int ret = CallService(MS_PROTO_CHAINSEND, wParam, lParam);
+		}
+		if (otr_context_get_trust(context) >= TRUST_UNVERIFIED) ccs->wParam;
+		int ret = CallService(MS_PROTO_CHAINSEND, wParam, lParam);
 
 /*#ifdef _DEBUG
 		if(ccs->wParam & PREF_UNICODE)
 			MessageBox(0, (wchar_t *)ccs->lParam, _T("OTR - sending raw message"), MB_OK);
 		else 
-			MessageBoxA(0, (char *)ccs->lParam, ("OTR - sending raw message"), MB_OK);
-#endif*/
-
-		// reset to original values
-		ccs->lParam = (LPARAM)oldmessage;
-		ccs->wParam = oldflags;
-		otrl_message_free(newmessage);
-		return ret;
-
+			MessageBoxA(0, (char *)ccs->lParam, ("OTR - sending raw message"), MB_OK);
+#endif*/
+
+		// reset to original values
+		ccs->lParam = (LPARAM)oldmessage;
+		ccs->wParam = oldflags;
+		otrl_message_free(newmessage);
+		return ret;
+
     }
 
 	return CallService(MS_PROTO_CHAINSEND, wParam, lParam);
@@ -165,141 +165,141 @@
 	if(!oldmessage_utf) return 1;
 
 
-	char *newmessage = NULL;
-	OtrlTLV *tlvs = NULL;
-	OtrlTLV *tlv = NULL;
-	BOOL ignore_msg;
-	ConnContext *context;
-	//NextExpectedSMP nextMsg;
-
-	lib_cs_lock();
-	ignore_msg = otrl_message_receiving(otr_user_state, &ops, (void*)ccs->hContact,
-		proto, proto, uname, oldmessage_utf,
-		&newmessage, &tlvs, add_appdata, (void*)ccs->hContact);
-	lib_cs_unlock();
-
-	if( !(pre->flags & PREF_UTF)) mir_free(oldmessage_utf);
-	oldmessage_utf = NULL;
-
-
-	tlv = otrl_tlv_find(tlvs, OTRL_TLV_DISCONNECTED);
-	if (tlv) {
-		/* Notify the user that the other side disconnected. */
+	char *newmessage = NULL;
+	OtrlTLV *tlvs = NULL;
+	OtrlTLV *tlv = NULL;
+	BOOL ignore_msg;
+	ConnContext *context;
+	//NextExpectedSMP nextMsg;
+
+	lib_cs_lock();
+	ignore_msg = otrl_message_receiving(otr_user_state, &ops, (void*)ccs->hContact,
+		proto, proto, uname, oldmessage_utf,
+		&newmessage, &tlvs, add_appdata, (void*)ccs->hContact);
+	lib_cs_unlock();
+
+	if( !(pre->flags & PREF_UTF)) mir_free(oldmessage_utf);
+	oldmessage_utf = NULL;
+
+
+	tlv = otrl_tlv_find(tlvs, OTRL_TLV_DISCONNECTED);
+	if (tlv) {
+		/* Notify the user that the other side disconnected. */
 		TCHAR buff[256];
 		mir_sntprintf(buff, 256, TranslateT(LANG_SESSION_TERMINATED_BY_OTR), contact_get_nameT(ccs->hContact));
 		//MessageBox(0, buff, Translate("OTR Information"), MB_OK);
 		ShowMessage((HANDLE)ccs->hContact, buff);
 
-		//if(options.timeout_finished) ResetFinishedTimer();
-	}
-
-	lib_cs_lock();
-	context = otrl_context_find_miranda(otr_user_state, ccs->hContact);
-	lib_cs_unlock();
-	/* Keep track of our current progress in the Socialist Millionaires'
-	* Protocol. */
-	if (context && ( (context->smstate->sm_prog_state == OTRL_SMP_PROG_CHEATED) ||
-			otrl_tlv_find(tlvs, OTRL_TLV_SMP1Q) ||
-			otrl_tlv_find(tlvs, OTRL_TLV_SMP1) ||
-			otrl_tlv_find(tlvs, OTRL_TLV_SMP2) || 
-			otrl_tlv_find(tlvs, OTRL_TLV_SMP3) ||
-			otrl_tlv_find(tlvs, OTRL_TLV_SMP4) )
-			)
-	{
-		otr_abort_smp(context); // we do not support it (yet), notify partner to shorten wait time
-	}
-
-
-	/*
-	if (context) {
-		nextMsg = context->smstate->nextExpected;
-
-		if (context->smstate->sm_prog_state == OTRL_SMP_PROG_CHEATED) {
-			otr_abort_smp(context);
-			otrg_dialog_update_smp(context, 0.0);
-			context->smstate->nextExpected = OTRL_SMP_EXPECT1;
-			context->smstate->sm_prog_state = OTRL_SMP_PROG_OK;
-		} else {
-			
-			tlv = otrl_tlv_find(tlvs, OTRL_TLV_SMP1Q);
-			if (tlv) {
-				if (nextMsg != OTRL_SMP_EXPECT1)
-					otr_abort_smp(context);
-				else {
-					char *question = (char *)tlv->data;
-					char *eoq = (char*)memchr(question, '\0', tlv->len);
-					if (eoq) {
-						otrg_dialog_socialist_millionaires_q(context,
-							question);
-					}
-				}
-			}
-			tlv = otrl_tlv_find(tlvs, OTRL_TLV_SMP1);
-			if (tlv) {
-				if (nextMsg != OTRL_SMP_EXPECT1)
-					otr_abort_smp(context);
-				else {
-					otrg_dialog_socialist_millionaires(context);
-				}
-			}
-			tlv = otrl_tlv_find(tlvs, OTRL_TLV_SMP2);
-			if (tlv) {
-				if (nextMsg != OTRL_SMP_EXPECT2)
-					otr_abort_smp(context);
-				else {
-					otrg_dialog_update_smp(context, 0.6);
-					context->smstate->nextExpected = OTRL_SMP_EXPECT4;
-				}
-			}
-			tlv = otrl_tlv_find(tlvs, OTRL_TLV_SMP3);
-			if (tlv) {
-				if (nextMsg != OTRL_SMP_EXPECT3)
-					otr_abort_smp(context);
-				else {
-					otrg_dialog_update_smp(context, 1.0);
-					context->smstate->nextExpected = OTRL_SMP_EXPECT1;
-				}
-			}
-			tlv = otrl_tlv_find(tlvs, OTRL_TLV_SMP4);
-			if (tlv) {
-				if (nextMsg != OTRL_SMP_EXPECT4)
-					otr_abort_smp(context);
-				else {
-					otrg_dialog_update_smp(context, 1.0);
-					context->smstate->nextExpected = OTRL_SMP_EXPECT1;
-				}
-			}
-			tlv = otrl_tlv_find(tlvs, OTRL_TLV_SMP_ABORT);
-			if (tlv) {
-				otrg_dialog_update_smp(context, 0.0);
-				context->smstate->nextExpected = OTRL_SMP_EXPECT1;
-			}
-		}
-	}
-	*/
-
-	otrl_tlv_free(tlvs);
-
-	mir_free(uname);
-
-	/* If we're supposed to ignore this incoming message (because it's a
-	* protocol message), set it to NULL, so that other plugins that
-	* catch receiving-im-msg don't return 0, and cause it to be
-	* displayed anyway. */
-	if (ignore_msg) {
-		/* should not be required ;)
-		char t[3] = {0, 0, 0};
+		//if(options.timeout_finished) ResetFinishedTimer();
+	}
+
+	lib_cs_lock();
+	context = otrl_context_find_miranda(otr_user_state, ccs->hContact);
+	lib_cs_unlock();
+	/* Keep track of our current progress in the Socialist Millionaires'
+	* Protocol. */
+	if (context && ( (context->smstate->sm_prog_state == OTRL_SMP_PROG_CHEATED) ||
+			otrl_tlv_find(tlvs, OTRL_TLV_SMP1Q) ||
+			otrl_tlv_find(tlvs, OTRL_TLV_SMP1) ||
+			otrl_tlv_find(tlvs, OTRL_TLV_SMP2) || 
+			otrl_tlv_find(tlvs, OTRL_TLV_SMP3) ||
+			otrl_tlv_find(tlvs, OTRL_TLV_SMP4) )
+			)
+	{
+		otr_abort_smp(context); // we do not support it (yet), notify partner to shorten wait time
+	}
+
+
+	/*
+	if (context) {
+		nextMsg = context->smstate->nextExpected;
+
+		if (context->smstate->sm_prog_state == OTRL_SMP_PROG_CHEATED) {
+			otr_abort_smp(context);
+			otrg_dialog_update_smp(context, 0.0);
+			context->smstate->nextExpected = OTRL_SMP_EXPECT1;
+			context->smstate->sm_prog_state = OTRL_SMP_PROG_OK;
+		} else {
+			
+			tlv = otrl_tlv_find(tlvs, OTRL_TLV_SMP1Q);
+			if (tlv) {
+				if (nextMsg != OTRL_SMP_EXPECT1)
+					otr_abort_smp(context);
+				else {
+					char *question = (char *)tlv->data;
+					char *eoq = (char*)memchr(question, '\0', tlv->len);
+					if (eoq) {
+						otrg_dialog_socialist_millionaires_q(context,
+							question);
+					}
+				}
+			}
+			tlv = otrl_tlv_find(tlvs, OTRL_TLV_SMP1);
+			if (tlv) {
+				if (nextMsg != OTRL_SMP_EXPECT1)
+					otr_abort_smp(context);
+				else {
+					otrg_dialog_socialist_millionaires(context);
+				}
+			}
+			tlv = otrl_tlv_find(tlvs, OTRL_TLV_SMP2);
+			if (tlv) {
+				if (nextMsg != OTRL_SMP_EXPECT2)
+					otr_abort_smp(context);
+				else {
+					otrg_dialog_update_smp(context, 0.6);
+					context->smstate->nextExpected = OTRL_SMP_EXPECT4;
+				}
+			}
+			tlv = otrl_tlv_find(tlvs, OTRL_TLV_SMP3);
+			if (tlv) {
+				if (nextMsg != OTRL_SMP_EXPECT3)
+					otr_abort_smp(context);
+				else {
+					otrg_dialog_update_smp(context, 1.0);
+					context->smstate->nextExpected = OTRL_SMP_EXPECT1;
+				}
+			}
+			tlv = otrl_tlv_find(tlvs, OTRL_TLV_SMP4);
+			if (tlv) {
+				if (nextMsg != OTRL_SMP_EXPECT4)
+					otr_abort_smp(context);
+				else {
+					otrg_dialog_update_smp(context, 1.0);
+					context->smstate->nextExpected = OTRL_SMP_EXPECT1;
+				}
+			}
+			tlv = otrl_tlv_find(tlvs, OTRL_TLV_SMP_ABORT);
+			if (tlv) {
+				otrg_dialog_update_smp(context, 0.0);
+				context->smstate->nextExpected = OTRL_SMP_EXPECT1;
+			}
+		}
+	}
+	*/
+
+	otrl_tlv_free(tlvs);
+
+	mir_free(uname);
+
+	/* If we're supposed to ignore this incoming message (because it's a
+	* protocol message), set it to NULL, so that other plugins that
+	* catch receiving-im-msg don't return 0, and cause it to be
+	* displayed anyway. */
+	if (ignore_msg) {
+		/* should not be required ;)
+		char t[3] = {0, 0, 0};
 		if(pre->flags & PREF_UNICODE) { //TODO!! lstrlen(pre->szMessage)+1 ??
 			if (pre->szMessage && strlen(pre->szMessage)) memcpy(pre->szMessage, t,3 );
 		} else {
 			if (pre->szMessage && strlen(pre->szMessage)) memcpy(pre->szMessage, t, 1);
-		}
-		*/
-		if (newmessage) otrl_message_free(newmessage);
-		return 1;
-	} else if (newmessage) {
-		//bool free=false;
-		DWORD flags = pre->flags;
+		}
+		*/
+		if (newmessage) otrl_message_free(newmessage);
+		return 1;
+	} else if (newmessage) {
+		//bool free=false;
+		DWORD flags = pre->flags;
 		/* if(pre->flags & PREF_UTF) {
 			oldmessage_utf = newmessage;
 		} else if(pre->flags & PREF_UNICODE) { //TODO!! lstrlen(pre->szMessage)+1 ??
@@ -308,64 +308,64 @@
 		} else {
 			 mir_utf8decode(newmessage, NULL);
 			 oldmessage_utf = newmessage;
-		} */ 
-
-		//pre->szMessage = oldmessage_utf;
-		pre->flags &= ~PREF_UNICODE;
-		pre->flags |= PREF_UTF; // just use UTF, so we do not have to recode the message
-
-		bool is_miralloc = false;
-		if (context) {
-			TrustLevel level = otr_context_get_trust(context);
-			if (options.prefix_messages && (level == TRUST_PRIVATE || level == TRUST_UNVERIFIED)) {
-				DWORD len = (strlen(options.prefix)+strlen(newmessage)+1)*sizeof(char);
-				char* premsg = (char*)mir_alloc( len );
-				memset(premsg, 0, len);
-				strcpy(premsg, options.prefix);
-				strcat(premsg, newmessage);
-				otrl_message_free(newmessage);
-				newmessage = premsg;
-				is_miralloc = true;
-			}
-		}
-		pre->szMessage = newmessage;
-		BOOL ret = CallService(MS_PROTO_CHAINRECV, wParam, lParam);
-		pre->flags = flags;
-		pre->szMessage = oldmessage;
-		if (is_miralloc)
-			mir_free(newmessage);
-		else
-			otrl_message_free(newmessage);
-
-		// if (free) mir_free(oldmessage_utf);
-		return ret;
+		} */ 
+
+		//pre->szMessage = oldmessage_utf;
+		pre->flags &= ~PREF_UNICODE;
+		pre->flags |= PREF_UTF; // just use UTF, so we do not have to recode the message
+
+		bool is_miralloc = false;
+		if (context) {
+			TrustLevel level = otr_context_get_trust(context);
+			if (options.prefix_messages && (level == TRUST_PRIVATE || level == TRUST_UNVERIFIED)) {
+				DWORD len = (strlen(options.prefix)+strlen(newmessage)+1)*sizeof(char);
+				char* premsg = (char*)mir_alloc( len );
+				memset(premsg, 0, len);
+				strcpy(premsg, options.prefix);
+				strcat(premsg, newmessage);
+				otrl_message_free(newmessage);
+				newmessage = premsg;
+				is_miralloc = true;
+			}
+		}
+		pre->szMessage = newmessage;
+		BOOL ret = CallService(MS_PROTO_CHAINRECV, wParam, lParam);
+		pre->flags = flags;
+		pre->szMessage = oldmessage;
+		if (is_miralloc)
+			mir_free(newmessage);
+		else
+			otrl_message_free(newmessage);
+
+		// if (free) mir_free(oldmessage_utf);
+		return ret;
 	}
 	return CallService(MS_PROTO_CHAINRECV, wParam, lParam);
 
 }
 
-/* Abort the SMP protocol.  Used when malformed or unexpected messages
- * are received. */
-void otr_abort_smp(ConnContext *context)
-{
-    otrl_message_abort_smp(otr_user_state, &ops, context->app_data, context);
-}
-
-/* Start the Socialist Millionaires' Protocol over the current connection,
- * using the given initial secret, and optionally a question to pass to
- * the buddy. */
-void otr_start_smp(ConnContext *context, const char *question,
-	const unsigned char *secret, size_t secretlen)
-{
-    otrl_message_initiate_smp_q(otr_user_state, &ops, context->app_data,
-	    context, question, secret, secretlen);
-}
-
-/* Continue the Socialist Millionaires' Protocol over the current connection,
- * using the given initial secret (ie finish step 2). */
-void otr_continue_smp(ConnContext *context,
-	const unsigned char *secret, size_t secretlen)
-{
-	otrl_message_respond_smp(otr_user_state, &ops, context->app_data,
-	    context, secret, secretlen);
+/* Abort the SMP protocol.  Used when malformed or unexpected messages
+ * are received. */
+void otr_abort_smp(ConnContext *context)
+{
+    otrl_message_abort_smp(otr_user_state, &ops, context->app_data, context);
+}
+
+/* Start the Socialist Millionaires' Protocol over the current connection,
+ * using the given initial secret, and optionally a question to pass to
+ * the buddy. */
+void otr_start_smp(ConnContext *context, const char *question,
+	const unsigned char *secret, size_t secretlen)
+{
+    otrl_message_initiate_smp_q(otr_user_state, &ops, context->app_data,
+	    context, question, secret, secretlen);
+}
+
+/* Continue the Socialist Millionaires' Protocol over the current connection,
+ * using the given initial secret (ie finish step 2). */
+void otr_continue_smp(ConnContext *context,
+	const unsigned char *secret, size_t secretlen)
+{
+	otrl_message_respond_smp(otr_user_state, &ops, context->app_data,
+	    context, secret, secretlen);
 }
\ No newline at end of file
Index: MirOTR/utils.cpp
===================================================================
--- MirOTR/utils.cpp	(revision 4)
+++ MirOTR/utils.cpp	(working copy)
@@ -1,24 +1,24 @@
-#include "stdafx.h"
-#include "utils.h"
-
-CRITICAL_SECTION lib_cs;
-
-void InitUtils() {
-	InitializeCriticalSection(&lib_cs);
-}
-void DeinitUtils() {
-	DeleteCriticalSection(&lib_cs);
-}
-
+#include "stdafx.h"
+#include "utils.h"
+
+CRITICAL_SECTION lib_cs;
+
+void InitUtils() {
+	InitializeCriticalSection(&lib_cs);
+}
+void DeinitUtils() {
+	DeleteCriticalSection(&lib_cs);
+}
+
 void lib_cs_lock() {
 	EnterCriticalSection(&lib_cs);
 }
 
 void lib_cs_unlock() {
 	LeaveCriticalSection(&lib_cs);
-}
-
-HANDLE find_contact(const char* userid, const char* protocol) {
+}
+
+HANDLE find_contact(const char* userid, const char* protocol) {
 	HANDLE hContact = ( HANDLE )CallService( MS_DB_CONTACT_FINDFIRST, 0, 0 );
 	while ( hContact != NULL )
 	{
@@ -34,62 +34,62 @@
 		hContact = ( HANDLE )CallService( MS_DB_CONTACT_FINDNEXT,( WPARAM )hContact, 0 );
 	}
 	
-	return 0;
-}
-
-/* Look up a connection context by hContact from the given
-* OtrlUserState.  If add_if_missing is true, allocate and return a new
-* context if one does not currently exist.  In that event, call
-* add_app_data(data, context) so that app_data and app_data_free can be
-* filled in by the application, and set *addedp to 1. */
-ConnContext * otrl_context_find_miranda(OtrlUserState us, HANDLE hContact)
-{
-	ConnContext ** curp;
-	if (!hContact) return NULL;
-	for (curp = &(us->context_root); *curp; curp = &((*curp)->next)) {
-		if ((*curp)->app_data == hContact ) return *curp;
-	}
-	return NULL;
-}
-
-/* What level of trust do we have in the privacy of this ConnContext? */
-TrustLevel otr_context_get_trust(ConnContext *context)
-{
-	TrustLevel level = TRUST_NOT_PRIVATE;
-
-	if (context && context->msgstate == OTRL_MSGSTATE_ENCRYPTED) {
-		if (context->active_fingerprint->trust &&
-			context->active_fingerprint->trust[0] != '\0') {
-				level = TRUST_PRIVATE;
-		} else {
-			level = TRUST_UNVERIFIED;
-		}
-	} else if (context && context->msgstate == OTRL_MSGSTATE_FINISHED) {
-		level = TRUST_FINISHED;
-	}
-
-	return level;
-}
-
-/* Convert a 20-byte hash value to a 45-byte human-readable value */
-void otrl_privkey_hash_to_humanT(TCHAR human[45], const unsigned char hash[20])
-{
-    int word, byte;
-    TCHAR *p = human;
-
-    for(word=0; word<5; ++word) {
-	for(byte=0; byte<4; ++byte) {
-	    _stprintf(p, _T("%02X"), hash[word*4+byte]);
-	    p += 2;
-	}
-	*(p++) = ' ';
-    }
-    /* Change that last ' ' to a '\0' */
-    --p;
-    *p = '\0';
-}
-
-char* contact_get_id(HANDLE hContact, bool bNameOnError) {
+	return 0;
+}
+
+/* Look up a connection context by hContact from the given
+* OtrlUserState.  If add_if_missing is true, allocate and return a new
+* context if one does not currently exist.  In that event, call
+* add_app_data(data, context) so that app_data and app_data_free can be
+* filled in by the application, and set *addedp to 1. */
+ConnContext * otrl_context_find_miranda(OtrlUserState us, HANDLE hContact)
+{
+	ConnContext ** curp;
+	if (!hContact) return NULL;
+	for (curp = &(us->context_root); *curp; curp = &((*curp)->next)) {
+		if ((*curp)->app_data == hContact ) return *curp;
+	}
+	return NULL;
+}
+
+/* What level of trust do we have in the privacy of this ConnContext? */
+TrustLevel otr_context_get_trust(ConnContext *context)
+{
+	TrustLevel level = TRUST_NOT_PRIVATE;
+
+	if (context && context->msgstate == OTRL_MSGSTATE_ENCRYPTED) {
+		if (context->active_fingerprint->trust &&
+			context->active_fingerprint->trust[0] != '\0') {
+				level = TRUST_PRIVATE;
+		} else {
+			level = TRUST_UNVERIFIED;
+		}
+	} else if (context && context->msgstate == OTRL_MSGSTATE_FINISHED) {
+		level = TRUST_FINISHED;
+	}
+
+	return level;
+}
+
+/* Convert a 20-byte hash value to a 45-byte human-readable value */
+void otrl_privkey_hash_to_humanT(TCHAR human[45], const unsigned char hash[20])
+{
+    int word, byte;
+    TCHAR *p = human;
+
+    for(word=0; word<5; ++word) {
+	for(byte=0; byte<4; ++byte) {
+	    _stprintf(p, _T("%02X"), hash[word*4+byte]);
+	    p += 2;
+	}
+	*(p++) = ' ';
+    }
+    /* Change that last ' ' to a '\0' */
+    --p;
+    *p = '\0';
+}
+
+char* contact_get_id(HANDLE hContact, bool bNameOnError) {
 	char* pszUniqueID = NULL;
 	CONTACTINFO ci;
 	ZeroMemory(&ci, sizeof(ci));
@@ -114,29 +114,29 @@
 			if (pszUniqueID)
 				mir_snprintf(pszUniqueID, 15, ("%u"), ci.bVal);
 		}
-	}
-	if (!pszUniqueID && bNameOnError) {
-		char *name = (char *)CallService( MS_CLIST_GETCONTACTDISPLAYNAME, ( WPARAM )hContact, 0 );
-		if (name) pszUniqueID = mir_strdup(name);
-	}
-	return pszUniqueID;
-}
-
-__inline const TCHAR* contact_get_nameT(HANDLE hContact) {
-	return (TCHAR*)CallService( MS_CLIST_GETCONTACTDISPLAYNAME, ( WPARAM )hContact, GCDNF_TCHAR );
-}
-
-__inline const char* contact_get_proto(HANDLE hContact) {
-	char *uproto = (char *)CallService(MS_PROTO_GETCONTACTBASEPROTO, (WPARAM)hContact, 0);
-	return uproto;
-}
-
-__inline const char* contact_get_account(HANDLE hContact) {
-	char *uacc = (char *)CallService(MS_PROTO_GETCONTACTBASEACCOUNT, (WPARAM)hContact, 0);
-	return uacc;
-}
-
-void ShowPopup(const TCHAR* line1, const TCHAR* line2, int timeout, const HANDLE hContact) {
+	}
+	if (!pszUniqueID && bNameOnError) {
+		char *name = (char *)CallService( MS_CLIST_GETCONTACTDISPLAYNAME, ( WPARAM )hContact, 0 );
+		if (name) pszUniqueID = mir_strdup(name);
+	}
+	return pszUniqueID;
+}
+
+__inline const TCHAR* contact_get_nameT(HANDLE hContact) {
+	return (TCHAR*)CallService( MS_CLIST_GETCONTACTDISPLAYNAME, ( WPARAM )hContact, GCDNF_TCHAR );
+}
+
+__inline const char* contact_get_proto(HANDLE hContact) {
+	char *uproto = (char *)CallService(MS_PROTO_GETCONTACTBASEPROTO, (WPARAM)hContact, 0);
+	return uproto;
+}
+
+__inline const char* contact_get_account(HANDLE hContact) {
+	char *uacc = (char *)CallService(MS_PROTO_GETCONTACTBASEACCOUNT, (WPARAM)hContact, 0);
+	return uacc;
+}
+
+void ShowPopup(const TCHAR* line1, const TCHAR* line2, int timeout, const HANDLE hContact) {
 	if(CallService(MS_SYSTEM_TERMINATED, 0, 0)) return;
 
 	if ( !options.bHavePopups) {	
